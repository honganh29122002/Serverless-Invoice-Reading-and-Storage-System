[
{
	"uri": "http://localhost:1313/vi/6-lambda/6.1-scandb/",
	"title": "Lấy Dữ Liệu Từ DB",
	"tags": [],
	"description": "",
	"content": "Cấu hình Lambda Truy cập Amazon Lambda Console Tạo function mới:\nTên function Run time: Python 3.12 Architecture: x86_64 Tên IAM Role Nhập code sau đây import json import boto3 import logging # Cấu hình logging logging.basicConfig(level=logging.INFO) logger = logging.getLogger() dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(\u0026#39;InvoicesTable\u0026#39;) def format_invoice_text(invoice): \u0026#34;\u0026#34;\u0026#34;Chuyển đổi thông tin hóa đơn thành định dạng văn bản dễ đọc\u0026#34;\u0026#34;\u0026#34; formatted_text = [] formatted_text.append(f\u0026#34;\u0026lt;h2\u0026gt;Mã hóa đơn: {invoice.get(\u0026#39;InvoiceID\u0026#39;)}\u0026lt;/h2\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Ngày:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;InvoiceDate\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Thu ngân:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;Cashier\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Quầy:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;Counter\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phương thức thanh toán:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;PaymentMethod\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Khách đưa:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;CustomerPaid\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Tổng tiền:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;TotalAmount\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Chiết khấu:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;Discount\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Tiền thối:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;Change\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) # Danh sách sản phẩm items = invoice.get(\u0026#34;Items\u0026#34;, []) if items: formatted_text.append(\u0026#34;\u0026lt;h3\u0026gt;Danh sách sản phẩm:\u0026lt;/h3\u0026gt;\u0026#34;) formatted_text.append(\u0026#34;\u0026lt;table border=\u0026#39;1\u0026#39; cellpadding=\u0026#39;5\u0026#39; cellspacing=\u0026#39;0\u0026#39;\u0026gt;\u0026#34;) formatted_text.append(\u0026#34;\u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;#\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;Tên sản phẩm\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;Số lượng\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;Đơn giá\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;Thành tiền\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt;\u0026#34;) for idx, item in enumerate(items, 1): name = item.get(\u0026#34;name\u0026#34;) or \u0026#34;Không rõ\u0026#34; quantity = item.get(\u0026#34;quantity\u0026#34;) or \u0026#34;Không rõ\u0026#34; unit_price = item.get(\u0026#34;unit_price\u0026#34;) or \u0026#34;Không rõ\u0026#34; total_price = item.get(\u0026#34;total_price\u0026#34;) or \u0026#34;Không rõ\u0026#34; formatted_text.append(f\u0026#34;\u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;{idx}\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;{name}\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;{quantity}\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;{unit_price}\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;{total_price}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026#34;) formatted_text.append(\u0026#34;\u0026lt;/table\u0026gt;\u0026#34;) return \u0026#34;\u0026#34;.join(formatted_text) def lambda_handler(event, context): try: logger.info(\u0026#34;Bắt đầu xử lý yêu cầu.\u0026#34;) # Truy xuất toàn bộ dữ liệu từ bảng logger.info(\u0026#34;Truy xuất dữ liệu từ DynamoDB.\u0026#34;) response = table.scan() items = response.get(\u0026#39;Items\u0026#39;, []) logger.info(f\u0026#34;Số lượng hóa đơn lấy được: {len(items)}\u0026#34;) if not items: logger.warning(\u0026#34;Không có dữ liệu hóa đơn.\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 404, \u0026#39;headers\u0026#39;: { \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;*\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps({\u0026#34;message\u0026#34;: \u0026#34;Không có dữ liệu hóa đơn.\u0026#34;}) } # Định dạng dữ liệu thành dạng HTML formatted_result = \u0026#34;\u0026lt;div\u0026gt;\u0026#34; + \u0026#34;\u0026#34;.join([format_invoice_text(invoice) for invoice in items]) + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34; logger.info(\u0026#34;Hoàn thành việc xử lý dữ liệu và định dạng thành HTML.\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: { \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;*\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps({\u0026#34;formatted_result\u0026#34;: formatted_result}) } except Exception as e: logger.error(f\u0026#34;Lỗi khi xử lý yêu cầu: {str(e)}\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;headers\u0026#39;: { \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;*\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: str(e)}) } Lambda IAM Role Truy cập IAM Role và thêm policy Policy:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;dynamodb:GetItem\u0026#34;, \u0026#34;dynamodb:Query\u0026#34;, \u0026#34;dynamodb:Scan\u0026#34;, \u0026#34;dynamodb:BatchWriteItem\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:dynamodb:\u0026lt;YOUR-REGION\u0026gt;:\u0026lt;YOUR-ACCOUNT-ID\u0026gt;:table/\u0026lt;YOUR-NAME-TABLE\u0026gt;\u0026#34; } ] } Tiếp tục: 6.2 Lưu hình ảnh vào S3\n"
},
{
	"uri": "http://localhost:1313/vi/1-introduction/",
	"title": "Giới Thiệu",
	"tags": [],
	"description": "",
	"content": "Tổng Quan Workshop Workshop này tập trung vào việc xây dựng một ứng dụng serverless sử dụng các dịch vụ AWS, với sự nhấn mạnh đặc biệt vào xử lý tài liệu được hỗ trợ bởi AI và các cơ chế xác thực an toàn.\nThông qua trải nghiệm thực hành, bạn sẽ có được kiến thức thực tế trong việc cấu hình và tích hợp nhiều dịch vụ AWS để tạo ra một giải pháp serverless sẵn sàng cho sản xuất.\nKết Quả Học Tập Sau khi hoàn thành workshop này, bạn sẽ được trang bị kiến thức và kỹ năng để:\n1. Thiết Kế Kiến Trúc Serverless Thiết kế và triển khai các hệ thống serverless có thể mở rộng Sử dụng các dịch vụ cốt lõi: AWS Lambda, API Gateway, S3, Cognito và Route 53 Xây dựng các ứng dụng tiết kiệm chi phí mà không cần quản lý máy chủ 2. Xác Thực và Ủy Quyền Triển khai xác thực người dùng an toàn bằng Amazon Cognito Cấu hình kiểm soát truy cập và quản lý người dùng Tích hợp xác thực với API Gateway cho các endpoint an toàn 3. Tích Hợp Dịch Vụ Kết nối và điều phối nhiều dịch vụ AWS Tạo luồng dữ liệu hiệu quả giữa API Gateway, Lambda và S3 Xây dựng kiến trúc ứng dụng có thể mở rộng và bảo trì Tổng Quan Kiến Trúc Workshop này trình bày một hệ thống xử lý hóa đơn serverless hoàn chỉnh kết hợp hosting frontend, xác thực người dùng, xử lý tài liệu và phân tích được hỗ trợ bởi AI một cách an toàn và có thể mở rộng.\nTiếp tục 2. Frontend\nTài Liệu Tham Khảo AWS Serverless Application Lens AWS Well-Architected Framework Serverless Computing with AWS "
},
{
	"uri": "http://localhost:1313/vi/",
	"title": "Hệ Thống Đọc và Lưu Trữ Hóa Đơn Serverless",
	"tags": [],
	"description": "",
	"content": "Hệ Thống Đọc và Lưu Trữ Hóa Đơn Serverless Tổng Quan Hệ thống đại diện cho một kiến trúc hoàn toàn serverless và có khả năng mở rộng cao được xây dựng hoàn toàn trên các dịch vụ AWS cloud, được thiết kế để quản lý truy cập người dùng một cách an toàn, xử lý logic backend và lưu trữ dữ liệu hiệu quả. Tại điểm đầu vào, Amazon Route 53 chịu trách nhiệm phân giải DNS, định hướng các yêu cầu của client đến endpoint phù hợp. Các yêu cầu này sau đó được chuyển đến Amazon API Gateway, đóng vai trò là giao diện tập trung cho tất cả các tương tác bên ngoài với backend. API Gateway không chỉ xử lý việc định tuyến yêu cầu mà còn thực thi bảo mật bằng cách tích hợp với Amazon Cognito để xác thực và ủy quyền người dùng.\nKhi người dùng được xác thực, API Gateway chuyển tiếp yêu cầu đến các hàm AWS Lambda cụ thể chứa logic nghiệp vụ cốt lõi của ứng dụng. Ví dụ, hàm scan_lambda có thể chịu trách nhiệm xác thực, quét hoặc tiền xử lý đầu vào của người dùng, trong khi hàm savePicture xử lý dữ liệu phức tạp hơn và tải kết quả lên Amazon S3. Amazon S3 đóng vai trò là lớp lưu trữ bền vững của hệ thống, cung cấp độ bền cao, tính khả dụng và truy cập an toàn đến dữ liệu được lưu trữ. Toàn bộ hệ thống được điều khiển bởi sự kiện, tiết kiệm chi phí và có khả năng mở rộng tự động dựa trên nhu cầu, làm cho nó lý tưởng cho các ứng dụng hiện đại yêu cầu tính khả dụng cao, chi phí vận hành thấp và kiểm soát bảo mật mạnh mẽ. Ngoài ra, với giám sát, ghi log và số liệu tích hợp được cung cấp bởi các dịch vụ AWS như CloudWatch, hệ thống đảm bảo khả năng hiển thị và bảo trì trên tất cả các thành phần mà không cần quản lý máy chủ thủ công hoặc cung cấp cơ sở hạ tầng.\nMục Tiêu Không cần quản lý máy chủ – Hệ thống tự động mở rộng và được quản lý mà không cần duy trì máy chủ.\nBảo mật cao – Đảm bảo chỉ những người dùng được ủy quyền mới có thể truy cập dịch vụ.\nTối ưu hóa chi phí – Giá cả theo mức sử dụng, không có chi phí cơ sở hạ tầng cố định.\nHiệu suất cao – Xử lý nhanh chóng và điều chỉnh tự động dựa trên lượng traffic.\nTích hợp dễ dàng – Các dịch vụ AWS hoạt động liền mạch với nhau, đơn giản hóa việc phát triển và vận hành.\nCấu Trúc Workshop Workshop này được tổ chức thành các phần sau để hướng dẫn bạn xây dựng một hệ thống xử lý hóa đơn serverless hoàn chỉnh:\n1. Giới Thiệu Bắt đầu với tổng quan workshop, kết quả học tập và hiểu biết về kiến trúc.\n2. Frontend Cấu hình Amazon Route 53 để quản lý DNS và triển khai ứng dụng frontend bằng AWS Amplify.\n3. Xác Thực Triển khai xác thực và ủy quyền người dùng an toàn bằng Amazon Cognito.\n4. Lưu Trữ \u0026amp; Cơ Sở Dữ Liệu Thiết lập các giải pháp lưu trữ dữ liệu bằng Amazon S3 và DynamoDB cho ứng dụng của bạn.\n5. Document AI Tích hợp xử lý tài liệu được hỗ trợ bởi AI bằng Amazon Textract và Bedrock.\n6. Hàm Lambda Phát triển và triển khai các hàm serverless cho logic nghiệp vụ cốt lõi và xử lý dữ liệu.\n7. API Gateway Tạo và cấu hình RESTful API để kết nối frontend với các dịch vụ backend.\n8. Kiểm Thử Kiểm thử ứng dụng serverless hoàn chỉnh và xác minh tất cả các thành phần hoạt động cùng nhau.\n9. Xóa Nguồn Dọn dẹp các tài nguyên AWS để tránh chi phí không cần thiết sau khi hoàn thành workshop.\n10. Kết Luận Tóm tắt những thành tựu đạt được và các bước tiếp theo cho hành trình serverless của bạn.\nBắt Đầu Để bắt đầu workshop này, nhấp vào Giới Thiệu hoặc sử dụng menu điều hướng bên trái để tiến hành từng phần một cách tuần tự.\nĐảm bảo bạn có tài khoản AWS với quyền phù hợp trước khi bắt đầu workshop này.\n"
},
{
	"uri": "http://localhost:1313/vi/6-lambda/6.2-saveimagetos3/",
	"title": "Lưu Hình Ảnh Vào S3",
	"tags": [],
	"description": "",
	"content": "Cấu hình Lambda Truy cập Amazon Lambda Console Tạo function mới:\nTên function Run time: Python 3.12 Architecture: x86_64 Tên IAM Role Nhập code sau đây import boto3 import base64 import os s3 = boto3.client(\u0026#34;s3\u0026#34;) BUCKET_NAME = \u0026#34;invoicebuckett123\u0026#34; def lambda_handler(event, context): # Xử lý CORS preflight (OPTIONS request) if event[\u0026#34;httpMethod\u0026#34;] == \u0026#34;OPTIONS\u0026#34;: return { \u0026#34;statusCode\u0026#34;: 200, \u0026#34;headers\u0026#34;: { \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, # hoặc domain cụ thể nếu bạn muốn \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;POST,OPTIONS\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Content-Type,Authorization\u0026#34;, }, \u0026#34;body\u0026#34;: \u0026#34;\u0026#34; } try: file_name = event[\u0026#34;pathParameters\u0026#34;][\u0026#34;filename\u0026#34;] content_type = event[\u0026#34;headers\u0026#34;].get(\u0026#34;Content-Type\u0026#34;) or event[\u0026#34;headers\u0026#34;].get(\u0026#34;content-type\u0026#34;, \u0026#34;application/octet-stream\u0026#34;) file_content = base64.b64decode(event[\u0026#34;body\u0026#34;]) s3.put_object( Bucket=BUCKET_NAME, Key=file_name, Body=file_content, ContentType=content_type, ) return { \u0026#34;statusCode\u0026#34;: 200, \u0026#34;headers\u0026#34;: { \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, # hoặc domain cụ thể \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;POST,OPTIONS\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Content-Type,Authorization\u0026#34;, }, \u0026#34;body\u0026#34;: f\u0026#34;File \u0026#39;{file_name}\u0026#39; uploaded successfully to S3.\u0026#34; } except Exception as e: return { \u0026#34;statusCode\u0026#34;: 500, \u0026#34;headers\u0026#34;: { \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;POST,OPTIONS\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Content-Type,Authorization\u0026#34;, }, \u0026#34;body\u0026#34;: f\u0026#34;Upload failed: {str(e)}\u0026#34; } Lambda IAM Role Truy cập IAM Role và thêm policy { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;VisualEditor0\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;s3:PutObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::\u0026lt;YOUR-BUCKET-NAME\u0026gt;/*\u0026#34; } ] } Tiếp tục: 6.3 Tương tác với Textract\n"
},
{
	"uri": "http://localhost:1313/vi/2-frontend/",
	"title": "Frontend",
	"tags": [],
	"description": "",
	"content": "Phần này bao gồm việc thiết lập frontend cho hệ thống xử lý hóa đơn serverless, sử dụng Amazon Route 53 để quản lý DNS và AWS Amplify để hosting ứng dụng web.\nThiết Lập Amazon Route 53 Bước 1: Tạo Hosted Zone Điều hướng đến Amazon Route 53 Console\nNhấp Hosted zones → Create hosted zone Tên domain: Nhập tên domain đã đăng ký của bạn\nLoại: Chọn Public hosted zone\nXác nhận hosted zone được tạo thành công Bước 2: Xác Minh Tạo Hosted Zone Ghi chú các bản ghi NS và SOA mặc định\nSao chép các giá trị trong trường Value/Route traffic to\nCập nhật name servers của domain registrar để trỏ đến AWS Route 53\nCấu Hình AWS Amplify Bước 1: Khởi Tạo Ứng Dụng Amplify Điều hướng đến Amazon Amplify Console\nNhấp Deploy an app\nBước 2: Chọn Phương Thức Triển Khai Chọn Deploy without git\nNhấp Next\nBước 3: Upload File Ứng Dụng Nhập tên ứng dụng\nUpload file .zip ứng dụng từ máy local Mã Frontend\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Invoice Uploader\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/amazon-cognito-identity-js@6.3.7/dist/amazon-cognito-identity.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; margin: 30px; } form, button { margin-top: 20px; } #upload-form, #view-all-btn { display: none; } #result { background: #f4f4f4; padding: 10px; border: 1px solid #ccc; white-space: pre-wrap; } #view-all-result { background: #f4f4f4; padding: 10px; border: 1px solid #ccc; white-space: pre-wrap; margin-top: 20px; } table { width: 100%; border-collapse: collapse; margin-top: 20px; } th, td { padding: 8px 12px; border: 1px solid #ddd; text-align: left; } th { background-color: #f2f2f2; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;Login\u0026lt;/h2\u0026gt; \u0026lt;form id=\u0026#34;login-form\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; placeholder=\u0026#34;Username or Email\u0026#34; required /\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; placeholder=\u0026#34;Password\u0026#34; required /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div id=\u0026#34;login-message\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;Upload Invoice\u0026lt;/h2\u0026gt; \u0026lt;form id=\u0026#34;upload-form\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;invoice-file\u0026#34; accept=\u0026#34;.pdf,.jpg,.jpeg,.png,.txt\u0026#34; required /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Upload\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;h3\u0026gt;Result\u0026lt;/h3\u0026gt; \u0026lt;pre id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;h3\u0026gt;View All Invoices\u0026lt;/h3\u0026gt; \u0026lt;!-- Nút bấm để gọi API view-all và hiển thị dữ liệu --\u0026gt; \u0026lt;button id=\u0026#34;view-all-btn\u0026#34;\u0026gt;View All Invoices\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;view-all-result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const loginForm = document.getElementById(\u0026#34;login-form\u0026#34;); const uploadForm = document.getElementById(\u0026#34;upload-form\u0026#34;); const loginMessage = document.getElementById(\u0026#34;login-message\u0026#34;); const resultEl = document.getElementById(\u0026#34;result\u0026#34;); const viewAllBtn = document.getElementById(\u0026#34;view-all-btn\u0026#34;); const viewAllResultEl = document.getElementById(\u0026#34;view-all-result\u0026#34;); const API_GATEWAY_UPLOAD_URL = \u0026#34;https://fvfgkbr294.execute-api.ap-southeast-1.amazonaws.com/dev/invoicebuckett123/{filename}\u0026#34;; const API_GATEWAY_VIEW_ALL_URL = \u0026#34;https://fvfgkbr294.execute-api.ap-southeast-1.amazonaws.com/dev/view-all\u0026#34;; // URL cho view-all API const poolData = { UserPoolId: \u0026#34;ap-southeast-1_noiKt1wrx\u0026#34;, ClientId: \u0026#34;3rodaicnohm5pnh5q3105qccvd\u0026#34;, }; const userPool = new AmazonCognitoIdentity.CognitoUserPool(poolData); // Đăng nhập Cognito loginForm.addEventListener(\u0026#34;submit\u0026#34;, function (e) { e.preventDefault(); const username = document.getElementById(\u0026#34;username\u0026#34;).value; const password = document.getElementById(\u0026#34;password\u0026#34;).value; console.log(\u0026#34;Đăng nhập với:\u0026#34;, { username }); loginMessage.style.color = \u0026#34;blue\u0026#34;; loginMessage.textContent = \u0026#34;Đang đăng nhập...\u0026#34;; const authDetails = new AmazonCognitoIdentity.AuthenticationDetails({ Username: username, Password: password }); const cognitoUser = new AmazonCognitoIdentity.CognitoUser({ Username: username, Pool: userPool }); cognitoUser.authenticateUser(authDetails, { onSuccess: function (result) { const token = result.getIdToken().getJwtToken(); console.log(\u0026#34;Đăng nhập thành công - Token:\u0026#34;, token); window.idToken = token; loginMessage.style.color = \u0026#34;green\u0026#34;; loginMessage.textContent = \u0026#34;Đăng nhập thành công!\u0026#34;; loginForm.style.display = \u0026#34;none\u0026#34;; uploadForm.style.display = \u0026#34;block\u0026#34;; viewAllBtn.style.display = \u0026#34;inline-block\u0026#34;; // Hiển thị nút View All }, onFailure: function (err) { console.error(\u0026#34;Lỗi đăng nhập:\u0026#34;, err); loginMessage.style.color = \u0026#34;red\u0026#34;; loginMessage.textContent = \u0026#34;Đăng nhập thất bại: \u0026#34; + err.message; } }); }); // Upload hóa đơn uploadForm.addEventListener(\u0026#34;submit\u0026#34;, async function (e) { e.preventDefault(); const file = document.getElementById(\u0026#34;invoice-file\u0026#34;).files[0]; if (!file) { console.warn(\u0026#34;Không có file được chọn\u0026#34;); resultEl.textContent = \u0026#34;Vui lòng chọn file để upload.\u0026#34;; return; } const fileName = encodeURIComponent(file.name); const uploadUrl = API_GATEWAY_UPLOAD_URL.replace(\u0026#34;{filename}\u0026#34;, fileName); const idToken = window.idToken; if (!idToken) { console.error(\u0026#34;Không tìm thấy ID token.\u0026#34;); resultEl.textContent = \u0026#34;Bạn chưa đăng nhập hoặc phiên đăng nhập đã hết hạn.\u0026#34;; return; } console.log(\u0026#34;Chuẩn bị upload:\u0026#34;, { fileName, uploadUrl, fileType: file.type, fileSize: file.size, }); try { const arrayBuffer = await file.arrayBuffer(); const response = await fetch(uploadUrl, { method: \u0026#34;POST\u0026#34;, headers: { Authorization: idToken, \u0026#34;Content-Type\u0026#34;: file.type || \u0026#34;application/octet-stream\u0026#34;, }, body: arrayBuffer, }); console.log(\u0026#34;Response status:\u0026#34;, response.status); const resultText = await response.text(); console.log(\u0026#34;Phản hồi từ Lambda:\u0026#34;, resultText); resultEl.textContent = resultText; } catch (error) { console.error(\u0026#34;Lỗi upload:\u0026#34;, error); resultEl.textContent = \u0026#34;Lỗi upload: \u0026#34; + error.message; } }); // Gọi API View All Invoices viewAllBtn.addEventListener(\u0026#34;click\u0026#34;, async function () { const idToken = window.idToken; if (!idToken) { console.error(\u0026#34;Không tìm thấy ID token.\u0026#34;); viewAllResultEl.textContent = \u0026#34;Bạn chưa đăng nhập hoặc phiên đăng nhập đã hết hạn.\u0026#34;; return; } console.log(\u0026#34;Đang gọi API View All Invoices\u0026#34;); try { const response = await fetch(API_GATEWAY_VIEW_ALL_URL, { method: \u0026#34;GET\u0026#34;, headers: { Authorization: idToken, }, }); if (response.ok) { const data = await response.json(); console.log(\u0026#34;Dữ liệu hóa đơn:\u0026#34;, data); // Hiển thị kết quả dưới dạng HTML được trả về từ Lambda viewAllResultEl.innerHTML = data.formatted_result; // Hiển thị kết quả dưới dạng HTML } else { console.error(\u0026#34;Lỗi khi gọi API View All:\u0026#34;, response.status); viewAllResultEl.textContent = \u0026#34;Lỗi khi gọi API View All.\u0026#34;; } } catch (error) { console.error(\u0026#34;Lỗi gọi API View All:\u0026#34;, error); viewAllResultEl.textContent = \u0026#34;Lỗi kết nối với API View All: \u0026#34; + error.message; } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Bước 4: Triển Khai Ứng Dụng Xem lại cài đặt cấu hình\nNhấp Save and deploy\nBước 5: Cấu Hình Custom Domain Điều hướng đến Domain management\nNhấp Add domain Bước 6: Cấu Hình Domain Nhập tên custom domain của bạn\nNhấp Configure domain\nBước 7: Xác Minh Triển Khai Đợi xác minh domain và cấp phát SSL certificate\nXác nhận ứng dụng có thể truy cập được qua custom domain\nBước 4: Triển Khai Ứng Dụng Xem lại cài đặt cấu hình\nNhấp Save and deploy\nBước 5: Cấu Hình Custom Domain Điều hướng đến Domain management\nNhấp Add domain\nBước 6: Cấu Hình Domain Nhập tên custom domain của bạn\nNhấp Configure domain\nBước 7: Xác Minh Triển Khai Đợi xác minh domain và cấp phát SSL certificate\nXác nhận ứng dụng có thể truy cập được qua custom domain\nTiếp tục 3. Xác Thực\nTài Liệu Tham Khảo Amazon Route 53 Documentation AWS Amplify User Guide Custom Domain Configuration "
},
{
	"uri": "http://localhost:1313/vi/6-lambda/6.3-withtextract/",
	"title": "Tương Tác Với Textract",
	"tags": [],
	"description": "",
	"content": "Cấu hình Lambda Truy cập Amazon Lambda Console Tạo function mới:\nTên function Run time: Python 3.12 Architecture: x86_64 Tên IAM Role Nhập code sau đây import boto3 import json import os from urllib.parse import unquote_plus from decimal import Decimal # AWS clients textract = boto3.client(\u0026#39;textract\u0026#39;) lambda_client = boto3.client(\u0026#39;lambda\u0026#39;) dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table_name = os.environ.get(\u0026#34;TABLE_NAME\u0026#34;, \u0026#34;InvoicesTable\u0026#34;) table = dynamodb.Table(table_name) # ----------- Helper Functions -------------- def get_kv_map(bucket, key): response = textract.analyze_document( Document={\u0026#39;S3Object\u0026#39;: {\u0026#39;Bucket\u0026#39;: bucket, \u0026#39;Name\u0026#39;: key}}, FeatureTypes=[\u0026#39;FORMS\u0026#39;] ) blocks = response[\u0026#39;Blocks\u0026#39;] key_map, value_map, block_map = {}, {}, {} for block in blocks: block_id = block[\u0026#39;Id\u0026#39;] block_map[block_id] = block if block[\u0026#39;BlockType\u0026#39;] == \u0026#34;KEY_VALUE_SET\u0026#34;: if \u0026#39;KEY\u0026#39; in block[\u0026#39;EntityTypes\u0026#39;]: key_map[block_id] = block else: value_map[block_id] = block return key_map, value_map, block_map def find_value_block(key_block, value_map): for rel in key_block.get(\u0026#39;Relationships\u0026#39;, []): if rel[\u0026#39;Type\u0026#39;] == \u0026#39;VALUE\u0026#39;: for value_id in rel[\u0026#39;Ids\u0026#39;]: return value_map.get(value_id) return None def get_text(result, blocks_map): text = \u0026#39;\u0026#39; for rel in result.get(\u0026#39;Relationships\u0026#39;, []): if rel[\u0026#39;Type\u0026#39;] == \u0026#39;CHILD\u0026#39;: for child_id in rel[\u0026#39;Ids\u0026#39;]: word = blocks_map[child_id] if word[\u0026#39;BlockType\u0026#39;] == \u0026#39;WORD\u0026#39;: text += word[\u0026#39;Text\u0026#39;] + \u0026#39; \u0026#39; elif word[\u0026#39;BlockType\u0026#39;] == \u0026#39;SELECTION_ELEMENT\u0026#39;: if word[\u0026#39;SelectionStatus\u0026#39;] == \u0026#39;SELECTED\u0026#39;: text += \u0026#39;X \u0026#39; return text.strip() def get_kv_relationship(key_map, value_map, block_map): kvs = {} for key_block in key_map.values(): value_block = find_value_block(key_block, value_map) key = get_text(key_block, block_map) val = get_text(value_block, block_map) if value_block else \u0026#39;\u0026#39; kvs[key] = val return kvs def convert_floats_to_decimals(obj): if isinstance(obj, float): return Decimal(str(obj)) elif isinstance(obj, dict): return {k: convert_floats_to_decimals(v) for k, v in obj.items()} elif isinstance(obj, list): return [convert_floats_to_decimals(elem) for elem in obj] else: return obj def replace_none_with_zero(value): if value == \u0026#34;None\u0026#34;: return 0 return value def format_items(items): formatted_items = [] for item in items: formatted_item = { \u0026#34;name\u0026#34;: {\u0026#34;S\u0026#34;: item.get(\u0026#34;name\u0026#34;, \u0026#34;\u0026#34;)}, # Chỉ giữ lại \u0026#39;name\u0026#39; \u0026#34;unit_price\u0026#34;: {\u0026#34;N\u0026#34;: str(item.get(\u0026#34;unit_price\u0026#34;, 0))} # Chỉ giữ lại \u0026#39;unit_price\u0026#39; } formatted_items.append({\u0026#34;M\u0026#34;: formatted_item}) # Sử dụng \u0026#34;M\u0026#34; cho mỗi item return formatted_items # ----------- Lambda Handler ---------------- def lambda_handler(event, context): try: print(\u0026#34;Lambda A triggered\u0026#34;) record = event[\u0026#39;Records\u0026#39;][0] bucket = unquote_plus(record[\u0026#39;s3\u0026#39;][\u0026#39;bucket\u0026#39;][\u0026#39;name\u0026#39;]) key = unquote_plus(record[\u0026#39;s3\u0026#39;][\u0026#39;object\u0026#39;][\u0026#39;key\u0026#39;]) print(f\u0026#34;File uploaded: {key} in bucket: {bucket}\u0026#34;) # Step 1: Extract KV data using Textract key_map, value_map, block_map = get_kv_map(bucket, key) kvs = get_kv_relationship(key_map, value_map, block_map) print(f\u0026#34;Extracted {len(kvs)} key-value pairs\u0026#34;) print(f\u0026#34;Extracted key-value pairs: {json.dumps(kvs, indent=2)}\u0026#34;) # Step 2: Call Lambda B synchronously to process with Bedrock response = lambda_client.invoke( FunctionName=\u0026#39;bedrock_handle\u0026#39;, InvocationType=\u0026#39;RequestResponse\u0026#39;, Payload=json.dumps({ \u0026#39;form_data\u0026#39;: kvs }).encode(\u0026#39;utf-8\u0026#39;) ) response_payload = json.loads(response[\u0026#39;Payload\u0026#39;].read()) print(\u0026#34;Response from Lambda B:\u0026#34;, json.dumps(response_payload, indent=2)) # Step 3: Save to DynamoDB if valid if response_payload and isinstance(response_payload, dict): invoice_id = response_payload.get(\u0026#34;invoice_id\u0026#34;, \u0026#34;\u0026#34;).strip() if invoice_id: # Chỉ lưu lại name và unit_price trong items items = format_items(response_payload.get(\u0026#34;items\u0026#34;, [])) # Ensure InvoiceDate is not null or empty invoice_date = response_payload.get(\u0026#34;invoice_date\u0026#34;, \u0026#34;\u0026#34;) if not invoice_date: # Handle missing or empty InvoiceDate invoice_date = \u0026#34;N/A\u0026#34; # Assign a default value if missing item = convert_floats_to_decimals({ \u0026#34;InvoiceID\u0026#34;: invoice_id, \u0026#34;InvoiceDate\u0026#34;: invoice_date, \u0026#34;Cashier\u0026#34;: response_payload.get(\u0026#34;cashier\u0026#34;, \u0026#34;\u0026#34;), \u0026#34;Counter\u0026#34;: response_payload.get(\u0026#34;counter\u0026#34;, \u0026#34;\u0026#34;), \u0026#34;TotalAmount\u0026#34;: response_payload.get(\u0026#34;total_amount\u0026#34;, 0), \u0026#34;Discount\u0026#34;: response_payload.get(\u0026#34;discount\u0026#34;, 0), \u0026#34;CustomerPaid\u0026#34;: response_payload.get(\u0026#34;customer_paid\u0026#34;, 0), \u0026#34;Change\u0026#34;: response_payload.get(\u0026#34;change\u0026#34;, 0), \u0026#34;PaymentMethod\u0026#34;: response_payload.get(\u0026#34;payment_method\u0026#34;, \u0026#34;Tiền mặt\u0026#34;), \u0026#34;Items\u0026#34;: items }) print(\u0026#34;Saving item to DynamoDB:\u0026#34;, json.dumps(item, indent=2, default=str)) table.put_item(Item=item) print(\u0026#34;Data saved to DynamoDB successfully.\u0026#34;) else: print(\u0026#34;Invoice ID is missing. Data will not be saved to DynamoDB.\u0026#34;) else: print(\u0026#34;Lambda B did not return valid data.\u0026#34;) except Exception as e: print(f\u0026#34;[ERROR] Exception occurred: {str(e)}\u0026#34;, flush=True) raise IAM Role Truy cập IAM Role và thêm policy Tương tác với bedrock_handle lambda: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;lambda:InvokeFunction\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:lambda:\u0026lt;YOUR-REGION\u0026gt;:\u0026lt;YOUR-ACCOUNT-ID\u0026gt;:function:bedrock_handle\u0026#34; } ] } Tương tác với DynamoDB { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;VisualEditor0\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;dynamodb:PutItem\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:dynamodb:\u0026lt;YOUR-REGION\u0026gt;:\u0026lt;YOUR-ACCOUNT-ID\u0026gt;:table/\u0026lt;YOUR-TABLE-NAME\u0026gt;\u0026#34; } ] } Thêm Trigger Thêm S3 trigger: Mục đích thêm trigger là để khi hình ảnh được lưu vào S3, lambda sẽ bắt đầu xử lý thông tin hình ảnh đó. Tiếp tục: 6.4 Tương tác với Bedrock\n"
},
{
	"uri": "http://localhost:1313/vi/3-authentication/",
	"title": "Xác Thực",
	"tags": [],
	"description": "",
	"content": "Amazon Cognito là gì? Amazon Cognito đóng vai trò là dịch vụ xác thực và quản lý người dùng trung tâm trong các hệ thống dựa trên AWS, đảm bảo kiểm soát truy cập an toàn đến các tài nguyên backend như hàm Lambda và lưu trữ S3.\nCấu Hình Amazon Cognito Bước 1: Tạo User Pool Điều hướng đến Amazon Cognito Console Nhấp Create User Pool Bước 2: Cấu Hình Cài Đặt Ứng Dụng Loại ứng dụng: Single-page application\nTên ứng dụng: Nhập tên ứng dụng của bạn\nTùy chọn đăng nhập: Username\nReturn URL: Nhập URL ứng dụng của bạn\nThuộc tính bắt buộc cho đăng ký: email Bước 3: Truy Cập Giao Diện Đăng Nhập Xem lại cấu hình trang đăng nhập được host\nKiểm thử giao diện đăng nhập\nBước 4: Lưu Chi Tiết Cấu Hình Quan trọng: Ghi lại các giá trị sau để tích hợp ứng dụng:\nUser Pool ID Client ID Bước 5: Tạo Tài Khoản Người Dùng Thử Nghiệm Tạo tài khoản người dùng mới để kiểm thử\nHoàn thành quy trình đăng ký\nBước 6: Xác Minh Xác Thực Đăng nhập bằng thông tin đăng nhập đã tạo Xác minh xác thực thành công Nhập username và password bạn đã thiết lập trước đó. Thay đổi mật khẩu và xác nhận Bước 7: Xác Nhận Trạng Thái Người Dùng Xác minh trạng thái người dùng hiển thị là Confirmed\nNgười dùng hiện đã sẵn sàng để truy cập ứng dụng\nTiếp tục 4. Lưu Trữ \u0026amp; Cơ Sở Dữ Liệu\nTài Liệu Tham Khảo Amazon Cognito Documentation Cognito User Pools Authentication Best Practices "
},
{
	"uri": "http://localhost:1313/vi/4-storage-db/",
	"title": "Cấu Hình Lưu Trữ và Cơ Sở Dữ Liệu",
	"tags": [],
	"description": "",
	"content": "Phần này bao gồm việc thiết lập các thành phần lưu trữ dữ liệu bao gồm DynamoDB cho dữ liệu có cấu trúc và S3 cho lưu trữ file.\nCấu Hình Amazon DynamoDB Bước 1: Truy Cập DynamoDB Console Điều hướng đến DynamoDB Console\nBước 2: Tạo Bảng Mới Nhấp Create table\nCấu hình cài đặt bảng\nBước 3: Định Nghĩa Schema Bảng Tên bảng: Nhập tên bảng mô tả\nPartition key: Định nghĩa thuộc tính khóa chính\nSort key: Cấu hình khóa phụ (nếu cần)\nBước 4: Lưu Cấu Hình Bảng Xác minh việc tạo bảng thành công\nQuan trọng: Ghi lại ARN của bảng để cấu hình hàm Lambda\nCấu Hình Amazon S3 Bước 1: Truy Cập S3 Console Điều hướng đến S3 Console\nBước 2: Tạo S3 Bucket Nhấp Create bucket\nCấu hình cài đặt bucket\nBước 3: Cấu Hình Thuộc Tính Bucket Tên bucket: Nhập tên bucket duy nhất\nVùng: Chọn vùng AWS phù hợp\nCài đặt truy cập: Cấu hình theo yêu cầu bảo mật\nBước 4: Lưu Cấu Hình Bucket Xác minh việc tạo bucket thành công\nQuan trọng: Ghi lại ARN của bucket để cấu hình hàm Lambda và ứng dụng\nTiếp tục 5. Document AI\nTài Liệu Tham Khảo Amazon DynamoDB Documentation Amazon S3 User Guide DynamoDB Best Practices "
},
{
	"uri": "http://localhost:1313/vi/6-lambda/6.4-withbedrock/",
	"title": "Tương Tác Với Bedrock",
	"tags": [],
	"description": "",
	"content": "Cấu hình Lambda Truy cập Amazon Lambda Console Tạo function mới:\nTên function Run time: Python 3.12 Architecture: x86_64 Tên IAM Role Nhập code sau đây import boto3 import json bedrock = boto3.client(\u0026#39;bedrock-runtime\u0026#39;) def invoke_bedrock(form_data): prompt = f\u0026#34;\u0026#34;\u0026#34; Dưới đây là dữ liệu biểu mẫu hóa đơn bán lẻ đã được Textract trích xuất: {json.dumps(form_data, indent=2)} Hãy phân tích và trả về một JSON với cấu trúc sau: {{ \u0026#34;invoice_id\u0026#34;: string, \u0026#34;invoice_date\u0026#34;: string, \u0026#34;cashier\u0026#34;: string, \u0026#34;counter\u0026#34;: string, \u0026#34;total_amount\u0026#34;: number, \u0026#34;discount\u0026#34;: number, \u0026#34;customer_paid\u0026#34;: number, \u0026#34;change\u0026#34;: number, \u0026#34;payment_method\u0026#34;: string, \u0026#34;items\u0026#34;: [ {{ \u0026#34;name\u0026#34;: string, \u0026#34;unit_price\u0026#34;: number }} ... ] }} Chỉ trả về đúng một chuỗi JSON hợp lệ. \u0026#34;\u0026#34;\u0026#34; try: # Gửi yêu cầu tới mô hình Bedrock response = bedrock.invoke_model( modelId=\u0026#34;anthropic.claude-3-haiku-20240307-v1:0\u0026#34;, contentType=\u0026#34;application/json\u0026#34;, accept=\u0026#34;application/json\u0026#34;, body=json.dumps({ \u0026#34;anthropic_version\u0026#34;: \u0026#34;bedrock-2023-05-31\u0026#34;, \u0026#34;messages\u0026#34;: [ { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt } ], \u0026#34;max_tokens\u0026#34;: 1024, \u0026#34;temperature\u0026#34;: 0.3 }) ) raw_output = json.loads(response[\u0026#39;body\u0026#39;].read()) print(\u0026#34;Raw output from Claude:\u0026#34;, raw_output) messages = raw_output.get(\u0026#34;content\u0026#34;, []) if isinstance(messages, list) and len(messages) \u0026gt; 0: text_content = messages[0].get(\u0026#34;text\u0026#34;, \u0026#34;\u0026#34;) start_index = text_content.find(\u0026#34;{\u0026#34;) end_index = text_content.rfind(\u0026#34;}\u0026#34;) + 1 if start_index != -1 and end_index != -1: json_string = text_content[start_index:end_index] # Trả về JSON hợp lệ return json.loads(json_string) else: print(\u0026#34;Không tìm thấy JSON trong phản hồi từ Claude.\u0026#34;) return {\u0026#34;error\u0026#34;: \u0026#34;No valid JSON found in Claude response\u0026#34;, \u0026#34;data\u0026#34;: text_content} else: print(\u0026#34;Claude trả về dữ liệu không hợp lệ.\u0026#34;) return {\u0026#34;error\u0026#34;: \u0026#34;Invalid response from Claude\u0026#34;} except Exception as e: print(f\u0026#34;Error invoking Bedrock: {str(e)}\u0026#34;) return {\u0026#34;error\u0026#34;: \u0026#34;Error invoking Bedrock\u0026#34;, \u0026#34;message\u0026#34;: str(e)} def lambda_handler(event, context): print(\u0026#34;Lambda B triggered\u0026#34;) # Lấy dữ liệu form_data từ event form_data = event.get(\u0026#34;form_data\u0026#34;, {}) # Nếu form_data không có, trả về lỗi ngay lập tức if not form_data: return {\u0026#34;error\u0026#34;: \u0026#34;No form data provided\u0026#34;} # Gọi hàm invoke_bedrock để lấy kết quả từ mô hình Claude summary = invoke_bedrock(form_data) # In ra kết quả từ Claude (nếu có) print(\u0026#34;Claude summary:\u0026#34;, summary) return summary IAM Role Truy cập IAM Role và thêm policy { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;bedrock:InvokeModel\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;textract:AnalyzeDocument\u0026#34;, \u0026#34;textract:DetectDocumentText\u0026#34;, \u0026#34;textract:GetDocumentAnalysis\u0026#34;, \u0026#34;textract:GetDocumentTextDetection\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;lambda:InvokeFunction\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:lambda:\u0026lt;YOUR-REGION\u0026gt;:\u0026lt;YOUR-ACCOUNT-ID\u0026gt;:function:lambdaToTextract\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;dynamodb:PutItem\u0026#34;, \u0026#34;dynamodb:BatchWriteItem\u0026#34;, \u0026#34;dynamodb:UpdateItem\u0026#34;, \u0026#34;dynamodb:Query\u0026#34;, \u0026#34;dynamodb:GetItem\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:dynamodb:\u0026lt;YOUR-REGION\u0026gt;:\u0026lt;YOUR-ACCOUNT-ID\u0026gt;:table/YOUR_TABLE_NAME\u0026#34; } ] } Tiếp tục: 7. Cấu Hình API Gateway\n"
},
{
	"uri": "http://localhost:1313/vi/5-document-ai/",
	"title": "Document AI",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ khám phá vai trò của Amazon Textract và Amazon Bedrock trong hệ thống xử lý hóa đơn serverless, cùng với cách Guardrails bảo vệ thông tin nhạy cảm.\nTổng Quan Kiến Trúc Hệ thống Document AI bao gồm các thành phần chính sau:\nAmazon S3: Lưu trữ hóa đơn đầu vào và kết quả xử lý AWS Lambda: Điều phối quy trình xử lý serverless Amazon Textract: Trích xuất dữ liệu từ hóa đơn Amazon Bedrock: Phân tích thông minh và xử lý thông tin Vai Trò của Amazon Textract Chức Năng Cốt Lõi Amazon Textract là dịch vụ machine learning được quản lý hoàn toàn chuyên dụng cho:\n1. Trích Xuất Văn Bản và Dữ Liệu Có Cấu Trúc\nNhận dạng và trích xuất văn bản từ hình ảnh và PDF Phát hiện các trường dữ liệu có cấu trúc như bảng và biểu mẫu Duy trì định dạng và bố cục của tài liệu gốc 2. Phân Tích Hóa Đơn và Biên Lai (Analyze Expense)\nTự động xác định các trường chính: Tên Nhà Cung Cấp Ngày Hóa Đơn Tổng Số Tiền Số Tiền Thuế Chi tiết các mục hàng Trích xuất thông tin với điểm tin cậy cao Hỗ trợ nhiều định dạng hóa đơn khác nhau 3. Xử Lý Theo Lô và Thời Gian Thực\nXử lý đồng bộ cho tài liệu nhỏ (\u0026lt; 5MB) Xử lý bất đồng bộ cho tài liệu lớn và xử lý theo lô Tích hợp trực tiếp với S3 để xử lý tự động Lợi Ích Trong Hệ Thống Độ Chính Xác Cao: Sử dụng mô hình deep learning được huấn luyện trên hàng triệu tài liệu Không Cần Huấn Luyện: Mô hình được huấn luyện sẵn và sẵn sàng sử dụng Có Thể Mở Rộng: Tự động mở rộng theo khối lượng công việc Tiết Kiệm Chi Phí: Chỉ trả tiền cho những gì bạn sử dụng Vai Trò của Amazon Bedrock Chức Năng Cốt Lõi Amazon Bedrock cung cấp nền tảng để truy cập các mô hình nền tảng thông qua API:\n1. Claude 3 Haiku - Mô Hình Được Chọn\nTốc Độ Cao: Thời gian phản hồi nhanh, phù hợp cho xử lý thời gian thực Tiết Kiệm Chi Phí: Chi phí thấp cho xử lý khối lượng lớn Hiệu Quả: Hiệu suất xuất sắc cho các tác vụ phân tích và tóm tắt Đa Ngôn Ngữ: Hỗ trợ tiếng Việt và nhiều ngôn ngữ khác 2. Phân Tích Thông Minh\nXác Minh Dữ Liệu: Xác thực độ chính xác của các giá trị số Phân Loại Tự Động: Phân loại hóa đơn theo loại hàng hóa/dịch vụ Phát Hiện Bất Thường: Xác định các giá trị không hợp lý Tóm Tắt Thông Tin: Tạo tóm tắt có ý nghĩa từ dữ liệu thô 3. Xử Lý Ngôn Ngữ Tự Nhiên\nHiểu ngữ cảnh và ý nghĩa của thông tin Trả lời câu hỏi về nội dung hóa đơn Tạo ra những hiểu biết sâu sắc và khuyến nghị Định dạng đầu ra theo yêu cầu (JSON, text, v.v.) Lợi Ích Trong Hệ Thống Serverless: Không cần quản lý cơ sở hạ tầng Dịch Vụ Được Quản Lý: AWS xử lý cập nhật và bảo trì mô hình Tính Khả Dụng Cao: SLA cao cho khối lượng công việc sản xuất Tích Hợp: Tích hợp dễ dàng với các dịch vụ AWS khác Ứng Dụng Trong Xử Lý Hóa Đơn Bảo Vệ Thông Tin Tài Chính: Ngăn chặn việc tiết lộ số tài khoản và thông tin thanh toán Tuân Thủ Quy Định: Đảm bảo tuân thủ các quy định Bảo Mật Dữ Liệu: Bảo vệ thông tin khách hàng và nhà cung cấp Kiểm Soát Chất Lượng: Đảm bảo chất lượng và đầu ra phù hợp Quy Trình Xử Lý Tổng Thể Bước 1: Thu Thập Tài Liệu Hóa đơn được tải lên S3 Hàm Lambda được kích hoạt tự động Xác thực và tiền xử lý Bước 2: Trích Xuất Dữ Liệu (Textract) API analyze_expense của Textract được gọi Trích xuất dữ liệu có cấu trúc từ hóa đơn Điểm tin cậy cho từng trường Bước 3: Phân Tích Thông Minh (Bedrock) Dữ liệu từ Textract được gửi đến Claude 3 Haiku AI phân tích, xác minh và tạo ra những hiểu biết sâu sắc Guardrails đảm bảo đầu ra an toàn Bước 4: Lưu Trữ Kết Quả Kết quả được định dạng và lưu trữ Metadata và audit trail Tích hợp với các hệ thống downstream Lợi Ích của Kiến Trúc Serverless 1. Khả Năng Mở Rộng\nTự động mở rộng theo nhu cầu Xử lý từ vài hóa đơn đến hàng nghìn mỗi giây Không cần lập kế hoạch dung lượng 2. Tối Ưu Hóa Chi Phí\nMô hình trả theo sử dụng Không có tài nguyên nhàn rỗi Quản lý tài nguyên tự động 3. Độ Tin Cậy\nKhả năng chịu lỗi tích hợp Thử lại tự động và xử lý lỗi Triển khai đa AZ 4. Bảo Trì\nChi phí vận hành tối thiểu Cập nhật và vá lỗi tự động Tập trung vào logic nghiệp vụ Tài Liệu Tham Khảo Tài Liệu Amazon Textract Hướng Dẫn Sử Dụng Amazon Bedrock Hướng Dẫn Mô Hình Claude 3 Haiku Tiếp tục 6. Hàm Lambda\n"
},
{
	"uri": "http://localhost:1313/vi/6-lambda/",
	"title": "Cấu Hình Lambda",
	"tags": [],
	"description": "",
	"content": "Phần này bao gồm việc cấu hình và triển khai các hàm serverless để cung cấp năng lượng cho quy trình xử lý tài liệu.\nTổng Quan Ứng dụng sử dụng nhiều hàm Lambda để xử lý các khía cạnh khác nhau của pipeline xử lý hóa đơn:\nDatabase Scanner: Truy xuất và quản lý dữ liệu từ DynamoDB Image Upload Handler: Xử lý việc tải file lên S3 Textract Integration: Trích xuất dữ liệu từ tài liệu hóa đơn Bedrock Integration: Cung cấp phân tích và hiểu biết sâu sắc được hỗ trợ bởi AI Kiến Trúc Hàm Mỗi hàm Lambda được thiết kế với các trách nhiệm cụ thể để duy trì sự tách biệt các mối quan tâm và tối ưu hóa hiệu suất. Các hàm hoạt động cùng nhau để tạo ra một pipeline xử lý serverless hoàn chỉnh có thể tự động mở rộng dựa trên nhu cầu.\nTiếp tục 7. API Gateway\nTài Liệu Tham Khảo AWS Lambda Documentation Lambda Best Practices Serverless Architecture Patterns "
},
{
	"uri": "http://localhost:1313/vi/7-api-gateway/",
	"title": "Cấu Hình API Gateway",
	"tags": [],
	"description": "",
	"content": "Phần này bao gồm việc thiết lập API Gateway để tạo các REST API an toàn, có thể mở rộng kết nối ứng dụng frontend với các hàm Lambda backend.\nTổng Quan API Gateway Chức Năng Cốt Lõi 1. Quản Lý Yêu Cầu\nĐóng vai trò là điểm vào duy nhất cho tất cả các yêu cầu của client Quản lý giao tiếp giữa frontend và các dịch vụ backend Cung cấp xử lý yêu cầu/phản hồi tập trung 2. Định Tuyến Yêu Cầu\nĐịnh tuyến các yêu cầu HTTP/HTTPS đến các dịch vụ backend phù hợp Chỉ đạo yêu cầu đến các hàm Lambda cụ thể dựa trên endpoints Hỗ trợ nhiều loại tích hợp (Lambda, HTTP, dịch vụ AWS) 3. Tích Hợp Bảo Mật\nTích hợp với Amazon Cognito để xác thực Hỗ trợ OAuth2 và ủy quyền tùy chỉnh Cung cấp quản lý API key và throttling Vai Trò Kiến Trúc Trong kiến trúc serverless của chúng ta, API Gateway đóng vai trò là lớp điều phối:\nNhận yêu cầu từ ứng dụng frontend Định tuyến yêu cầu quét dữ liệu đến hàm Database Scanner Chỉ đạo yêu cầu upload đến hàm Image Upload Handler Kết nối với hàm Textract Integration để xử lý tài liệu Liên kết với hàm Bedrock Integration để phân tích AI Quản lý xác thực thông qua tích hợp Cognito Cấu Hình API API Lưu Trữ và Xử Lý Hóa Đơn Bước 1: Tạo REST API Điều hướng đến Amazon API Gateway Console\nTạo API mới\nChọn REST API Nhập tên API và Tạo Bước 2: Tạo Upload Resource Tạo resource mới\nTên resource: Nhập tên mô tả Bật CORS: Chọn tùy chọn này Bước 3: Tạo Dynamic Path Resource Tạo child resource\nTên resource: {filename} Bật CORS: Chọn tùy chọn này Bước 4: Cấu Hình POST Method Tạo method để upload file\nLoại method: POST Lambda Proxy Integration: Bật Hàm Lambda: Chọn hàm xử lý upload S3 Bước 5: Cấu Hình Response Headers Thiết lập cấu hình response\nResponse headers: Access-Control-Allow-Origin Response body: application/json Bước 6: Cấu Hình Media Types Truy cập cài đặt API\nThêm media type cho upload file API Truy Xuất Dữ Liệu Bước 1: Tạo View Resource Tạo resource mới để truy xuất dữ liệu\nTên resource: view-all Bật CORS: Chọn tùy chọn này Tạo Bước 2: Cấu Hình GET Method Tạo method để truy xuất dữ liệu\nLoại method: GET Lambda Proxy Integration: Bật Hàm Lambda: Chọn hàm scanner DynamoDB Bước 3: Deploy API Deploy API để có thể truy cập được\nQuan trọng: Lưu URL deployment để tích hợp frontend Thực Hành Tốt Nhất Bảo Mật Luôn bật CORS cho các yêu cầu cross-origin Triển khai xác thực và ủy quyền phù hợp Sử dụng API keys để kiểm soát truy cập bổ sung Hiệu Suất Bật caching cho các endpoints được truy cập thường xuyên Cấu hình giới hạn throttling phù hợp Giám sát việc sử dụng API và các số liệu hiệu suất Giám Sát Thiết lập CloudWatch logging để debug Cấu hình cảnh báo cho tỷ lệ lỗi và độ trễ Sử dụng AWS X-Ray để tracing phân tán Tiếp tục 8. Kiểm Thử\n"
},
{
	"uri": "http://localhost:1313/vi/8-testing/",
	"title": "Kiểm Thử Ứng Dụng",
	"tags": [],
	"description": "",
	"content": "Phần này bao gồm các quy trình kiểm thử toàn diện để xác thực chức năng của hệ thống xử lý hóa đơn serverless.\nQuy Trình Kiểm Thử Bước 1: Kiểm Thử Xác Thực Test Case 1.1: Thử Đăng Nhập Không Hợp Lệ\nThử đăng nhập với tài khoản sai\nTest Case 1.2: Thử Đăng Nhập Hợp Lệ\nThử đăng nhập với tài khoản đúng\nBước 2: Kiểm Thử Upload File Chọn dữ liệu là hình ảnh hóa đơn với phần mở rộng .png\nUpload hình ảnh\nBước 3: Xác Minh Lưu Trữ Kiểm tra s3 bucket và xem ảnh đã được upload\nKiểm tra log lambda để xem dữ liệu đã được lưu vào DynamoDB thành công\nKiểm tra bảng trong DynamoDB\nBước 4: Kiểm Thử Truy Xuất Dữ Liệu Thử xem dữ liệu được lưu trữ trong dynamo thông qua frontend\nBước 5: Kiểm Thử Upload Nhiều File Tiếp tục upload một hóa đơn khác và cũng thành công.\nTiếp tục 9. Dọn Dẹp\nTài Liệu Tham Khảo AWS Testing Best Practices API Gateway Testing Lambda Function Testing "
},
{
	"uri": "http://localhost:1313/vi/9-delete-source/",
	"title": "Dọn Dẹp Tài Nguyên",
	"tags": [],
	"description": "",
	"content": "Phần này cung cấp hướng dẫn toàn diện để dọn dẹp tất cả các tài nguyên AWS được tạo trong workshop để tránh các khoản phí không cần thiết.\nDanh Sách Kiểm Tra Dọn Dẹp Giai Đoạn 1: Dọn Dẹp Lớp Ứng Dụng 1. AWS Amplify Hành động: Xóa ứng dụng Amplify Các bước: Điều hướng đến AWS Amplify Console Chọn ứng dụng của bạn Đi đến Actions → Delete app Xác nhận xóa bằng cách nhập tên app 2. Amazon Route 53 Hành động: Xóa hosted zone và records Các bước: Điều hướng đến Route 53 Console Xóa tất cả custom records (giữ NS và SOA cuối cùng) Xóa hosted zone Cập nhật cài đặt DNS của domain registrar (nếu có) Giai Đoạn 2: Dọn Dẹp API và Compute 1. Amazon API Gateway Hành động: Xóa REST API Các bước: Điều hướng đến API Gateway Console Chọn API của bạn Đi đến Actions → Delete API Xác nhận xóa 2. AWS Lambda Functions Hành động: Xóa tất cả hàm Lambda Các bước: Điều hướng đến Lambda Console Xóa từng hàm một cách riêng lẻ: Hàm database scanner Hàm xử lý upload hình ảnh Hàm tích hợp Textract Hàm tích hợp Bedrock Xác minh tất cả hàm đã được xóa Giai Đoạn 3: Dọn Dẹp Lưu Trữ và Cơ Sở Dữ Liệu 1. Amazon S3 Hành động: Làm trống và xóa S3 buckets Các bước: Điều hướng đến S3 Console Làm trống bucket trước: Chọn bucket → Empty Nhập \u0026ldquo;permanently delete\u0026rdquo; để xác nhận Xóa bucket: Chọn bucket → Delete Nhập tên bucket để xác nhận và delete bucket 2. Amazon DynamoDB Hành động: Xóa bảng DynamoDB Các bước: Điều hướng đến DynamoDB Console Chọn bảng của bạn Đi đến Actions → Delete table Nhập \u0026ldquo;delete\u0026rdquo; để xác nhận Đợi việc xóa hoàn tất Giai Đoạn 4: Dọn Dẹp Identity Amazon Cognito Hành động: Xóa User Pool Các bước: Điều hướng đến Cognito Console Chọn User Pool của bạn Đi đến Actions → Delete user pool Nhập \u0026ldquo;delete\u0026rdquo; để xác nhận Giai Đoạn 5: Dọn Dẹp Giám Sát và Logging CloudWatch Logs Hành động: Xóa log groups Các bước: Điều hướng đến CloudWatch Console Đi đến Logs → Log groups Xóa log groups của hàm Lambda Xóa log groups của API Gateway Quan trọng: Kiểm tra kỹ tất cả việc xóa trước khi xác nhận. Việc xóa tài nguyên thường không thể hoàn tác và có thể dẫn đến mất dữ liệu vĩnh viễn.\nTiếp tục 10. Kết Luận\nTài Liệu Tham Khảo AWS Resource Cleanup Best Practices AWS Cost Management AWS Billing and Cost Management User Guide "
},
{
	"uri": "http://localhost:1313/vi/10-conclusion/",
	"title": "Kết Luận",
	"tags": [],
	"description": "",
	"content": "Tóm Tắt Workshop Chúc mừng! Bạn đã hoàn thành thành công workshop Hệ Thống Đọc và Lưu Trữ Hóa Đơn Serverless. Thông qua trải nghiệm thực hành này, bạn đã xây dựng một ứng dụng serverless toàn diện, sẵn sàng cho sản xuất sử dụng nhiều dịch vụ AWS.\nNhững Gì Bạn Đã Đạt Được 1. Thành Thạo Kiến Trúc Serverless Thiết kế và triển khai hệ thống serverless hoàn toàn với khả năng tự động mở rộng Tích hợp nhiều dịch vụ AWS một cách liền mạch mà không cần quản lý máy chủ Tạo ra giải pháp tiết kiệm chi phí với mô hình trả theo sử dụng 2. Phát Triển \u0026amp; Hosting Frontend Cấu hình Amazon Route 53 để quản lý DNS Triển khai ứng dụng web responsive sử dụng AWS Amplify Triển khai cấu hình custom domain với SSL certificates 3. Bảo Mật \u0026amp; Xác Thực Thiết lập Amazon Cognito cho xác thực người dùng an toàn Triển khai ủy quyền dựa trên JWT token Cấu hình kiểm soát truy cập cho các API endpoints 4. Lưu Trữ \u0026amp; Quản Lý Dữ Liệu Cấu hình Amazon S3 để lưu trữ file với các chính sách truy cập phù hợp Thiết lập DynamoDB cho lưu trữ dữ liệu có cấu trúc Triển khai các mẫu truy xuất và quản lý dữ liệu hiệu quả 5. Xử Lý Tài Liệu Được Hỗ Trợ Bởi AI Tích hợp Amazon Textract cho phân tích tài liệu thông minh Triển khai Amazon Bedrock với Claude 3 Haiku cho AI insights Tạo quy trình xử lý hóa đơn tự động 6. Serverless Computing Phát triển nhiều hàm Lambda cho các logic nghiệp vụ khác nhau Triển khai các mẫu kiến trúc hướng sự kiện Tạo pipeline xử lý có thể mở rộng 7. Phát Triển API Xây dựng RESTful APIs sử dụng Amazon API Gateway Cấu hình CORS và security headers phù hợp Triển khai nhiều endpoints cho các chức năng khác nhau 8. Kiểm Thử \u0026amp; Xác Thực Thực hiện kiểm thử end-to-end toàn diện Xác thực luồng xác thực và xử lý dữ liệu Xác minh tích hợp hệ thống và chức năng Lợi Ích Chính Đạt Được Khả Năng Mở Rộng Tự động mở rộng dựa trên nhu cầu Không cần lập kế hoạch dung lượng Xử lý tăng đột biến traffic hiệu quả Tối Ưu Hóa Chi Phí Mô hình chỉ trả cho những gì sử dụng Không có chi phí tài nguyên nhàn rỗi Tối ưu hóa việc sử dụng tài nguyên Bảo Mật Triển khai bảo mật đa lớp Mã hóa truyền tải và lưu trữ dữ liệu Kiểm soát truy cập và xác thực phù hợp Khả Năng Bảo Trì Kiến trúc modular với tách biệt các mối quan tâm Dễ dàng cập nhật và mở rộng chức năng Logging và monitoring toàn diện Ứng Dụng Thực Tế Kiến trúc và các mẫu bạn đã học có thể được áp dụng cho nhiều trường hợp sử dụng:\nHệ Thống Xử Lý Tài Liệu: Tài liệu pháp lý, hồ sơ y tế, báo cáo tài chính Nền Tảng Quản Lý Nội Dung: Xử lý media, chia sẻ file, cộng tác tài liệu Giải Pháp E-commerce: Xử lý đơn hàng, quản lý kho, cổng khách hàng Tự Động Hóa Doanh Nghiệp: Tự động hóa quy trình, pipeline xử lý dữ liệu, hệ thống báo cáo Các Bước Tiếp Theo Nâng Cao Giải Pháp Thêm nhiều khả năng AI sử dụng các mô hình Bedrock bổ sung Triển khai tính năng phân tích và báo cáo nâng cao Thêm thông báo thời gian thực sử dụng Amazon SNS Tích hợp với các dịch vụ và API bên thứ ba Cân Nhắc Sản Xuất Triển khai monitoring toàn diện với CloudWatch Thiết lập backup tự động và khôi phục thảm họa Thêm các lớp tối ưu hóa hiệu suất và caching Triển khai CI/CD pipelines cho deployment tự động Tiếp Tục Học Tập Khám phá các dịch vụ và tính năng AWS nâng cao Học về các mẫu kiến trúc microservices Nghiên cứu DevOps và thực hành infrastructure as code Điều tra các mẫu tích hợp machine learning và AI Tài Nguyên Để Học Thêm AWS Well-Architected Framework AWS Serverless Application Lens AWS Lambda Best Practices Amazon API Gateway Developer Guide Suy Nghĩ Cuối Cùng Bạn đã xây dựng thành công một ứng dụng serverless tinh vi thể hiện các nguyên tắc kiến trúc cloud hiện đại. Các kỹ năng và kiến thức thu được từ workshop này cung cấp nền tảng vững chắc để xây dựng các giải pháp có thể mở rộng, an toàn và tiết kiệm chi phí trên cloud.\nHãy nhớ: Luôn tuân theo các quy trình dọn dẹp được nêu trong phần trước để tránh các khoản phí không cần thiết khi bạn hoàn thành việc thử nghiệm với triển khai của mình.\nCảm ơn bạn đã hoàn thành workshop này, và chúng tôi hy vọng đây là một trải nghiệm học tập có giá trị!\nTài Liệu Tham Khảo AWS Well-Architected Framework AWS Serverless Application Repository AWS Architecture Center AWS Training and Certification "
},
{
	"uri": "http://localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]