[
{
	"uri": "http://localhost:1313/6-lambda/6.1-scandb/",
	"title": "Get Data From DB",
	"tags": [],
	"description": "",
	"content": "Lambda configuration Access to Amazon Lambda Console Create a new function:\nFunction name Run time: Python 3.12 Architecture: x86_64 IAM Role name Enter the following code import json import boto3 import logging # Cấu hình logging logging.basicConfig(level=logging.INFO) logger = logging.getLogger() dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(\u0026#39;InvoicesTable\u0026#39;) def format_invoice_text(invoice): \u0026#34;\u0026#34;\u0026#34;Chuyển đổi thông tin hóa đơn thành định dạng văn bản dễ đọc\u0026#34;\u0026#34;\u0026#34; formatted_text = [] formatted_text.append(f\u0026#34;\u0026lt;h2\u0026gt;Mã hóa đơn: {invoice.get(\u0026#39;InvoiceID\u0026#39;)}\u0026lt;/h2\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Ngày:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;InvoiceDate\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Thu ngân:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;Cashier\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Quầy:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;Counter\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phương thức thanh toán:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;PaymentMethod\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Khách đưa:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;CustomerPaid\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Tổng tiền:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;TotalAmount\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Chiết khấu:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;Discount\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) formatted_text.append(f\u0026#34;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Tiền thối:\u0026lt;/strong\u0026gt; {invoice.get(\u0026#39;Change\u0026#39;)}\u0026lt;/p\u0026gt;\u0026#34;) # Danh sách sản phẩm items = invoice.get(\u0026#34;Items\u0026#34;, []) if items: formatted_text.append(\u0026#34;\u0026lt;h3\u0026gt;Danh sách sản phẩm:\u0026lt;/h3\u0026gt;\u0026#34;) formatted_text.append(\u0026#34;\u0026lt;table border=\u0026#39;1\u0026#39; cellpadding=\u0026#39;5\u0026#39; cellspacing=\u0026#39;0\u0026#39;\u0026gt;\u0026#34;) formatted_text.append(\u0026#34;\u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;#\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;Tên sản phẩm\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;Số lượng\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;Đơn giá\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;Thành tiền\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt;\u0026#34;) for idx, item in enumerate(items, 1): name = item.get(\u0026#34;name\u0026#34;) or \u0026#34;Không rõ\u0026#34; quantity = item.get(\u0026#34;quantity\u0026#34;) or \u0026#34;Không rõ\u0026#34; unit_price = item.get(\u0026#34;unit_price\u0026#34;) or \u0026#34;Không rõ\u0026#34; total_price = item.get(\u0026#34;total_price\u0026#34;) or \u0026#34;Không rõ\u0026#34; formatted_text.append(f\u0026#34;\u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;{idx}\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;{name}\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;{quantity}\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;{unit_price}\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;{total_price}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026#34;) formatted_text.append(\u0026#34;\u0026lt;/table\u0026gt;\u0026#34;) return \u0026#34;\u0026#34;.join(formatted_text) def lambda_handler(event, context): try: logger.info(\u0026#34;Bắt đầu xử lý yêu cầu.\u0026#34;) # Truy xuất toàn bộ dữ liệu từ bảng logger.info(\u0026#34;Truy xuất dữ liệu từ DynamoDB.\u0026#34;) response = table.scan() items = response.get(\u0026#39;Items\u0026#39;, []) logger.info(f\u0026#34;Số lượng hóa đơn lấy được: {len(items)}\u0026#34;) if not items: logger.warning(\u0026#34;Không có dữ liệu hóa đơn.\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 404, \u0026#39;headers\u0026#39;: { \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;*\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps({\u0026#34;message\u0026#34;: \u0026#34;Không có dữ liệu hóa đơn.\u0026#34;}) } # Định dạng dữ liệu thành dạng HTML formatted_result = \u0026#34;\u0026lt;div\u0026gt;\u0026#34; + \u0026#34;\u0026#34;.join([format_invoice_text(invoice) for invoice in items]) + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34; logger.info(\u0026#34;Hoàn thành việc xử lý dữ liệu và định dạng thành HTML.\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: { \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;*\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps({\u0026#34;formatted_result\u0026#34;: formatted_result}) } except Exception as e: logger.error(f\u0026#34;Lỗi khi xử lý yêu cầu: {str(e)}\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;headers\u0026#39;: { \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;*\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: str(e)}) } Lambda IAM Role Access to IAM Role and add policy Policy:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;dynamodb:GetItem\u0026#34;, \u0026#34;dynamodb:Query\u0026#34;, \u0026#34;dynamodb:Scan\u0026#34;, \u0026#34;dynamodb:BatchWriteItem\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:dynamodb:\u0026lt;YOUR-REGION\u0026gt;:\u0026lt;YOUR-ACCOUNT-ID\u0026gt;:table/\u0026lt;YOUR-NAME-TABLE\u0026gt;\u0026#34; } ] } Continue to: 6.2 Save picture to S3\n"
},
{
	"uri": "http://localhost:1313/1-introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Workshop Overview This workshop focuses on building a comprehensive serverless application using AWS services, with particular emphasis on AI-powered document processing and secure authentication mechanisms.\nThrough hands-on experience, you will gain practical knowledge in configuring and integrating multiple AWS services to create a production-ready serverless solution.\nLearning Outcomes By completing this workshop, you will be equipped with the knowledge and skills to:\n1. Serverless Architecture Design Design and deploy scalable serverless systems Utilize core services: AWS Lambda, API Gateway, S3, Cognito, and Route 53 Build cost-effective applications without server management overhead 2. Authentication and Authorization Implement secure user authentication using Amazon Cognito Configure access control and user management Integrate authentication with API Gateway for secure endpoints 3. Service Integration Connect and orchestrate multiple AWS services Create efficient data flow between API Gateway, Lambda, and S3 Build scalable and maintainable application architectures Architecture Overview The workshop demonstrates a complete serverless invoice processing system that combines frontend hosting, user authentication, document processing, and AI-powered analysis in a secure and scalable manner.\nContinue to 2. Frontend\nReferences AWS Serverless Application Lens AWS Well-Architected Framework Serverless Computing with AWS "
},
{
	"uri": "http://localhost:1313/",
	"title": "Serverless Invoice Reading and Storage System",
	"tags": [],
	"description": "",
	"content": "Serverless Invoice Reading and Storage System Overview The system represents a fully serverless and highly scalable architecture built entirely on AWS cloud services, designed to securely manage user access, handle backend logic, and store data efficiently. At the entry point, Amazon Route 53 is responsible for DNS resolution, directing client requests to the appropriate endpoint. These requests are then passed to Amazon API Gateway, which acts as the centralized interface for all external interactions with the backend. API Gateway not only handles the routing of requests but also enforces security by integrating with Amazon Cognito for user authentication and authorization.\nOnce a user is authenticated, API Gateway forwards the request to specific AWS Lambda functions that contain the core business logic of the application. For example, the scan_lambda function may be responsible for validating, scanning, or preprocessing user inputs, while the savePicture function handles more complex data processing and uploads results to Amazon S3. Amazon S3 serves as the system\u0026rsquo;s persistent storage layer, offering high durability, availability, and secure access to stored data. The entire system is event-driven, cost-efficient, and capable of scaling automatically based on demand, making it ideal for modern applications that require high availability, low operational overhead, and strong security controls. Additionally, with built-in monitoring, logging, and metrics provided by AWS services like CloudWatch, the system ensures visibility and maintainability across all components without requiring manual server management or infrastructure provisioning.\nTarget No server management – The system scales automatically and is managed without needing to maintain servers.\nHigh security – Ensures only authorized users can access services.\nCost optimization – Pay-as-you-go pricing, with no fixed infrastructure costs.\nHigh performance – Quick processing and automatic adjustment based on traffic volume.\nEasy integration – AWS services work seamlessly together, simplifying development and operations.\nWorkshop Structure This workshop is organized into the following sections to guide you through building a complete serverless invoice processing system:\n1. Introduction\n2. Frontend\n3. Authentication\n4. Storage \u0026amp; Database\n5. Document AI\n6. Lambda Functions\n7. API Gateway\n8. Testing\n9. Delete Source\n10. Conclusion\nGetting Started To begin this workshop, click on Introduction or use the navigation menu on the left to proceed through each section step by step.\nMake sure you have an AWS account with appropriate permissions before starting this workshop.\n"
},
{
	"uri": "http://localhost:1313/6-lambda/6.2-saveimagetos3/",
	"title": "Save Picture to S3",
	"tags": [],
	"description": "",
	"content": "Lambda configuration Access to Amazon Lambda Console Create a new function:\nFunction name Run time: Python 3.12 Architecture: x86_64 IAM Role name Enter the following code import boto3 import base64 import os s3 = boto3.client(\u0026#34;s3\u0026#34;) BUCKET_NAME = \u0026#34;invoicebuckett123\u0026#34; def lambda_handler(event, context): # Xử lý CORS preflight (OPTIONS request) if event[\u0026#34;httpMethod\u0026#34;] == \u0026#34;OPTIONS\u0026#34;: return { \u0026#34;statusCode\u0026#34;: 200, \u0026#34;headers\u0026#34;: { \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, # hoặc domain cụ thể nếu bạn muốn \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;POST,OPTIONS\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Content-Type,Authorization\u0026#34;, }, \u0026#34;body\u0026#34;: \u0026#34;\u0026#34; } try: file_name = event[\u0026#34;pathParameters\u0026#34;][\u0026#34;filename\u0026#34;] content_type = event[\u0026#34;headers\u0026#34;].get(\u0026#34;Content-Type\u0026#34;) or event[\u0026#34;headers\u0026#34;].get(\u0026#34;content-type\u0026#34;, \u0026#34;application/octet-stream\u0026#34;) file_content = base64.b64decode(event[\u0026#34;body\u0026#34;]) s3.put_object( Bucket=BUCKET_NAME, Key=file_name, Body=file_content, ContentType=content_type, ) return { \u0026#34;statusCode\u0026#34;: 200, \u0026#34;headers\u0026#34;: { \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, # hoặc domain cụ thể \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;POST,OPTIONS\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Content-Type,Authorization\u0026#34;, }, \u0026#34;body\u0026#34;: f\u0026#34;File \u0026#39;{file_name}\u0026#39; uploaded successfully to S3.\u0026#34; } except Exception as e: return { \u0026#34;statusCode\u0026#34;: 500, \u0026#34;headers\u0026#34;: { \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;POST,OPTIONS\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Content-Type,Authorization\u0026#34;, }, \u0026#34;body\u0026#34;: f\u0026#34;Upload failed: {str(e)}\u0026#34; } Lambda IAM Role Access to IAM Role and add policy { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;VisualEditor0\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;s3:PutObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::\u0026lt;YOUR-BUCKET-NAME\u0026gt;/*\u0026#34; } ] } Continue to: 6.3 Interact with textract\n"
},
{
	"uri": "http://localhost:1313/2-frontend/",
	"title": "Frontend",
	"tags": [],
	"description": "",
	"content": "Amazon Route 53 Setup Step 1: Create Hosted Zone Navigate to the Amazon Route 53 Console\nClick Hosted zones → Create hosted zone Domain name: Enter your registered domain name\nType: Select Public hosted zone\nConfirm the hosted zone is created successfully Step 2: Verify Hosted Zone Creation Note the default NS and SOA records\nCopy the Value/Route traffic to field values\nUpdate your domain registrar\u0026rsquo;s name servers to point to AWS Route 53\nAWS Amplify Configuration Step 1: Initialize Amplify Application Navigate to the Amazon Amplify Console\nClick Deploy an app\nStep 2: Choose Deployment Method Select Deploy without git\nClick Next\nStep 3: Upload Application Files Enter your App name\nUpload the Frontend.zip file from your local machine Code Frontend\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Invoice Uploader\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/amazon-cognito-identity-js@6.3.7/dist/amazon-cognito-identity.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; margin: 30px; } form, button { margin-top: 20px; } #upload-form, #view-all-btn { display: none; } #result { background: #f4f4f4; padding: 10px; border: 1px solid #ccc; white-space: pre-wrap; } #view-all-result { background: #f4f4f4; padding: 10px; border: 1px solid #ccc; white-space: pre-wrap; margin-top: 20px; } table { width: 100%; border-collapse: collapse; margin-top: 20px; } th, td { padding: 8px 12px; border: 1px solid #ddd; text-align: left; } th { background-color: #f2f2f2; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;Login\u0026lt;/h2\u0026gt; \u0026lt;form id=\u0026#34;login-form\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; placeholder=\u0026#34;Username or Email\u0026#34; required /\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; placeholder=\u0026#34;Password\u0026#34; required /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div id=\u0026#34;login-message\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;Upload Invoice\u0026lt;/h2\u0026gt; \u0026lt;form id=\u0026#34;upload-form\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;invoice-file\u0026#34; accept=\u0026#34;.pdf,.jpg,.jpeg,.png,.txt\u0026#34; required /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Upload\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;h3\u0026gt;Result\u0026lt;/h3\u0026gt; \u0026lt;pre id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;h3\u0026gt;View All Invoices\u0026lt;/h3\u0026gt; \u0026lt;!-- Nút bấm để gọi API view-all và hiển thị dữ liệu --\u0026gt; \u0026lt;button id=\u0026#34;view-all-btn\u0026#34;\u0026gt;View All Invoices\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;view-all-result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const loginForm = document.getElementById(\u0026#34;login-form\u0026#34;); const uploadForm = document.getElementById(\u0026#34;upload-form\u0026#34;); const loginMessage = document.getElementById(\u0026#34;login-message\u0026#34;); const resultEl = document.getElementById(\u0026#34;result\u0026#34;); const viewAllBtn = document.getElementById(\u0026#34;view-all-btn\u0026#34;); const viewAllResultEl = document.getElementById(\u0026#34;view-all-result\u0026#34;); const API_GATEWAY_UPLOAD_URL = \u0026#34;https://fvfgkbr294.execute-api.ap-southeast-1.amazonaws.com/dev/invoicebuckett123/{filename}\u0026#34;; const API_GATEWAY_VIEW_ALL_URL = \u0026#34;https://fvfgkbr294.execute-api.ap-southeast-1.amazonaws.com/dev/view-all\u0026#34;; // URL cho view-all API const poolData = { UserPoolId: \u0026#34;ap-southeast-1_noiKt1wrx\u0026#34;, ClientId: \u0026#34;3rodaicnohm5pnh5q3105qccvd\u0026#34;, }; const userPool = new AmazonCognitoIdentity.CognitoUserPool(poolData); // Đăng nhập Cognito loginForm.addEventListener(\u0026#34;submit\u0026#34;, function (e) { e.preventDefault(); const username = document.getElementById(\u0026#34;username\u0026#34;).value; const password = document.getElementById(\u0026#34;password\u0026#34;).value; console.log(\u0026#34;Đăng nhập với:\u0026#34;, { username }); loginMessage.style.color = \u0026#34;blue\u0026#34;; loginMessage.textContent = \u0026#34;Đang đăng nhập...\u0026#34;; const authDetails = new AmazonCognitoIdentity.AuthenticationDetails({ Username: username, Password: password }); const cognitoUser = new AmazonCognitoIdentity.CognitoUser({ Username: username, Pool: userPool }); cognitoUser.authenticateUser(authDetails, { onSuccess: function (result) { const token = result.getIdToken().getJwtToken(); console.log(\u0026#34;Đăng nhập thành công - Token:\u0026#34;, token); window.idToken = token; loginMessage.style.color = \u0026#34;green\u0026#34;; loginMessage.textContent = \u0026#34;Đăng nhập thành công!\u0026#34;; loginForm.style.display = \u0026#34;none\u0026#34;; uploadForm.style.display = \u0026#34;block\u0026#34;; viewAllBtn.style.display = \u0026#34;inline-block\u0026#34;; // Hiển thị nút View All }, onFailure: function (err) { console.error(\u0026#34;Lỗi đăng nhập:\u0026#34;, err); loginMessage.style.color = \u0026#34;red\u0026#34;; loginMessage.textContent = \u0026#34;Đăng nhập thất bại: \u0026#34; + err.message; } }); }); // Upload hóa đơn uploadForm.addEventListener(\u0026#34;submit\u0026#34;, async function (e) { e.preventDefault(); const file = document.getElementById(\u0026#34;invoice-file\u0026#34;).files[0]; if (!file) { console.warn(\u0026#34;Không có file được chọn\u0026#34;); resultEl.textContent = \u0026#34;Vui lòng chọn file để upload.\u0026#34;; return; } const fileName = encodeURIComponent(file.name); const uploadUrl = API_GATEWAY_UPLOAD_URL.replace(\u0026#34;{filename}\u0026#34;, fileName); const idToken = window.idToken; if (!idToken) { console.error(\u0026#34;Không tìm thấy ID token.\u0026#34;); resultEl.textContent = \u0026#34;Bạn chưa đăng nhập hoặc phiên đăng nhập đã hết hạn.\u0026#34;; return; } console.log(\u0026#34;Chuẩn bị upload:\u0026#34;, { fileName, uploadUrl, fileType: file.type, fileSize: file.size, }); try { const arrayBuffer = await file.arrayBuffer(); const response = await fetch(uploadUrl, { method: \u0026#34;POST\u0026#34;, headers: { Authorization: idToken, \u0026#34;Content-Type\u0026#34;: file.type || \u0026#34;application/octet-stream\u0026#34;, }, body: arrayBuffer, }); console.log(\u0026#34;Response status:\u0026#34;, response.status); const resultText = await response.text(); console.log(\u0026#34;Phản hồi từ Lambda:\u0026#34;, resultText); resultEl.textContent = resultText; } catch (error) { console.error(\u0026#34;Lỗi upload:\u0026#34;, error); resultEl.textContent = \u0026#34;Lỗi upload: \u0026#34; + error.message; } }); // Gọi API View All Invoices viewAllBtn.addEventListener(\u0026#34;click\u0026#34;, async function () { const idToken = window.idToken; if (!idToken) { console.error(\u0026#34;Không tìm thấy ID token.\u0026#34;); viewAllResultEl.textContent = \u0026#34;Bạn chưa đăng nhập hoặc phiên đăng nhập đã hết hạn.\u0026#34;; return; } console.log(\u0026#34;Đang gọi API View All Invoices\u0026#34;); try { const response = await fetch(API_GATEWAY_VIEW_ALL_URL, { method: \u0026#34;GET\u0026#34;, headers: { Authorization: idToken, }, }); if (response.ok) { const data = await response.json(); console.log(\u0026#34;Dữ liệu hóa đơn:\u0026#34;, data); // Hiển thị kết quả dưới dạng HTML được trả về từ Lambda viewAllResultEl.innerHTML = data.formatted_result; // Hiển thị kết quả dưới dạng HTML } else { console.error(\u0026#34;Lỗi khi gọi API View All:\u0026#34;, response.status); viewAllResultEl.textContent = \u0026#34;Lỗi khi gọi API View All.\u0026#34;; } } catch (error) { console.error(\u0026#34;Lỗi gọi API View All:\u0026#34;, error); viewAllResultEl.textContent = \u0026#34;Lỗi kết nối với API View All: \u0026#34; + error.message; } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Step 4: Deploy Application Review configuration settings\nClick Save and deploy\nStep 5: Configure Custom Domain Navigate to Domain management\nClick Add domain Step 6: Domain Configuration Enter your custom domain name\nClick Configure domain\nStep 7: Verify Deployment Wait for domain verification and SSL certificate provisioning\nConfirm the application is accessible via your custom domain\nContinue to 3. Authentication\nReferences Amazon Route 53 Documentation AWS Amplify User Guide Custom Domain Configuration "
},
{
	"uri": "http://localhost:1313/6-lambda/6.3-withtextract/",
	"title": "Interact with Textract",
	"tags": [],
	"description": "",
	"content": "Lambda configuration Access to Amazon Lambda Console Create a new function:\nFunction name Run time: Python 3.12 Architecture: x86_64 IAM Role name Enter the following code import boto3 import json import os from urllib.parse import unquote_plus from decimal import Decimal # AWS clients textract = boto3.client(\u0026#39;textract\u0026#39;) lambda_client = boto3.client(\u0026#39;lambda\u0026#39;) dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table_name = os.environ.get(\u0026#34;TABLE_NAME\u0026#34;, \u0026#34;InvoicesTable\u0026#34;) table = dynamodb.Table(table_name) # ----------- Helper Functions -------------- def get_kv_map(bucket, key): response = textract.analyze_document( Document={\u0026#39;S3Object\u0026#39;: {\u0026#39;Bucket\u0026#39;: bucket, \u0026#39;Name\u0026#39;: key}}, FeatureTypes=[\u0026#39;FORMS\u0026#39;] ) blocks = response[\u0026#39;Blocks\u0026#39;] key_map, value_map, block_map = {}, {}, {} for block in blocks: block_id = block[\u0026#39;Id\u0026#39;] block_map[block_id] = block if block[\u0026#39;BlockType\u0026#39;] == \u0026#34;KEY_VALUE_SET\u0026#34;: if \u0026#39;KEY\u0026#39; in block[\u0026#39;EntityTypes\u0026#39;]: key_map[block_id] = block else: value_map[block_id] = block return key_map, value_map, block_map def find_value_block(key_block, value_map): for rel in key_block.get(\u0026#39;Relationships\u0026#39;, []): if rel[\u0026#39;Type\u0026#39;] == \u0026#39;VALUE\u0026#39;: for value_id in rel[\u0026#39;Ids\u0026#39;]: return value_map.get(value_id) return None def get_text(result, blocks_map): text = \u0026#39;\u0026#39; for rel in result.get(\u0026#39;Relationships\u0026#39;, []): if rel[\u0026#39;Type\u0026#39;] == \u0026#39;CHILD\u0026#39;: for child_id in rel[\u0026#39;Ids\u0026#39;]: word = blocks_map[child_id] if word[\u0026#39;BlockType\u0026#39;] == \u0026#39;WORD\u0026#39;: text += word[\u0026#39;Text\u0026#39;] + \u0026#39; \u0026#39; elif word[\u0026#39;BlockType\u0026#39;] == \u0026#39;SELECTION_ELEMENT\u0026#39;: if word[\u0026#39;SelectionStatus\u0026#39;] == \u0026#39;SELECTED\u0026#39;: text += \u0026#39;X \u0026#39; return text.strip() def get_kv_relationship(key_map, value_map, block_map): kvs = {} for key_block in key_map.values(): value_block = find_value_block(key_block, value_map) key = get_text(key_block, block_map) val = get_text(value_block, block_map) if value_block else \u0026#39;\u0026#39; kvs[key] = val return kvs def convert_floats_to_decimals(obj): if isinstance(obj, float): return Decimal(str(obj)) elif isinstance(obj, dict): return {k: convert_floats_to_decimals(v) for k, v in obj.items()} elif isinstance(obj, list): return [convert_floats_to_decimals(elem) for elem in obj] else: return obj def replace_none_with_zero(value): if value == \u0026#34;None\u0026#34;: return 0 return value def format_items(items): formatted_items = [] for item in items: formatted_item = { \u0026#34;name\u0026#34;: {\u0026#34;S\u0026#34;: item.get(\u0026#34;name\u0026#34;, \u0026#34;\u0026#34;)}, # Chỉ giữ lại \u0026#39;name\u0026#39; \u0026#34;unit_price\u0026#34;: {\u0026#34;N\u0026#34;: str(item.get(\u0026#34;unit_price\u0026#34;, 0))} # Chỉ giữ lại \u0026#39;unit_price\u0026#39; } formatted_items.append({\u0026#34;M\u0026#34;: formatted_item}) # Sử dụng \u0026#34;M\u0026#34; cho mỗi item return formatted_items # ----------- Lambda Handler ---------------- def lambda_handler(event, context): try: print(\u0026#34;Lambda A triggered\u0026#34;) record = event[\u0026#39;Records\u0026#39;][0] bucket = unquote_plus(record[\u0026#39;s3\u0026#39;][\u0026#39;bucket\u0026#39;][\u0026#39;name\u0026#39;]) key = unquote_plus(record[\u0026#39;s3\u0026#39;][\u0026#39;object\u0026#39;][\u0026#39;key\u0026#39;]) print(f\u0026#34;File uploaded: {key} in bucket: {bucket}\u0026#34;) # Step 1: Extract KV data using Textract key_map, value_map, block_map = get_kv_map(bucket, key) kvs = get_kv_relationship(key_map, value_map, block_map) print(f\u0026#34;Extracted {len(kvs)} key-value pairs\u0026#34;) print(f\u0026#34;Extracted key-value pairs: {json.dumps(kvs, indent=2)}\u0026#34;) # Step 2: Call Lambda B synchronously to process with Bedrock response = lambda_client.invoke( FunctionName=\u0026#39;bedrock_handle\u0026#39;, InvocationType=\u0026#39;RequestResponse\u0026#39;, Payload=json.dumps({ \u0026#39;form_data\u0026#39;: kvs }).encode(\u0026#39;utf-8\u0026#39;) ) response_payload = json.loads(response[\u0026#39;Payload\u0026#39;].read()) print(\u0026#34;Response from Lambda B:\u0026#34;, json.dumps(response_payload, indent=2)) # Step 3: Save to DynamoDB if valid if response_payload and isinstance(response_payload, dict): invoice_id = response_payload.get(\u0026#34;invoice_id\u0026#34;, \u0026#34;\u0026#34;).strip() if invoice_id: # Chỉ lưu lại name và unit_price trong items items = format_items(response_payload.get(\u0026#34;items\u0026#34;, [])) # Ensure InvoiceDate is not null or empty invoice_date = response_payload.get(\u0026#34;invoice_date\u0026#34;, \u0026#34;\u0026#34;) if not invoice_date: # Handle missing or empty InvoiceDate invoice_date = \u0026#34;N/A\u0026#34; # Assign a default value if missing item = convert_floats_to_decimals({ \u0026#34;InvoiceID\u0026#34;: invoice_id, \u0026#34;InvoiceDate\u0026#34;: invoice_date, \u0026#34;Cashier\u0026#34;: response_payload.get(\u0026#34;cashier\u0026#34;, \u0026#34;\u0026#34;), \u0026#34;Counter\u0026#34;: response_payload.get(\u0026#34;counter\u0026#34;, \u0026#34;\u0026#34;), \u0026#34;TotalAmount\u0026#34;: response_payload.get(\u0026#34;total_amount\u0026#34;, 0), \u0026#34;Discount\u0026#34;: response_payload.get(\u0026#34;discount\u0026#34;, 0), \u0026#34;CustomerPaid\u0026#34;: response_payload.get(\u0026#34;customer_paid\u0026#34;, 0), \u0026#34;Change\u0026#34;: response_payload.get(\u0026#34;change\u0026#34;, 0), \u0026#34;PaymentMethod\u0026#34;: response_payload.get(\u0026#34;payment_method\u0026#34;, \u0026#34;Tiền mặt\u0026#34;), \u0026#34;Items\u0026#34;: items }) print(\u0026#34;Saving item to DynamoDB:\u0026#34;, json.dumps(item, indent=2, default=str)) table.put_item(Item=item) print(\u0026#34;Data saved to DynamoDB successfully.\u0026#34;) else: print(\u0026#34;Invoice ID is missing. Data will not be saved to DynamoDB.\u0026#34;) else: print(\u0026#34;Lambda B did not return valid data.\u0026#34;) except Exception as e: print(f\u0026#34;[ERROR] Exception occurred: {str(e)}\u0026#34;, flush=True) raise IAM Role Access to IAM Role and add policy Interact with bedrock_handle lambda: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;lambda:InvokeFunction\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:lambda:\u0026lt;YOUR-REGION\u0026gt;:\u0026lt;YOUR-ACCOUNT-ID\u0026gt;:function:bedrock_handle\u0026#34; } ] } Interact with DynamoDB { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;VisualEditor0\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;dynamodb:PutItem\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:dynamodb:\u0026lt;YOUR-REGION\u0026gt;:\u0026lt;YOUR-ACCOUNT-ID\u0026gt;:table/\u0026lt;YOUR-TABLE-NAME\u0026gt;\u0026#34; } ] } Add Trigger Add S3 trigger: The purpose of adding a trigger is so that when an image is saved to S3, lambda will start processing that image information. Continue to: 6.4 Interact with bedrock\n"
},
{
	"uri": "http://localhost:1313/3-authentication/",
	"title": "Authentication",
	"tags": [],
	"description": "",
	"content": "What is Amazon Cognito? Amazon Cognito serves as the central authentication and user management service within AWS-based systems, ensuring secure access control to backend resources such as Lambda functions and S3 storage.\nAmazon Cognito Configuration Step 1: Create User Pool Navigate to the Amazon Cognito Console Click Create User Pool Step 2: Configure Application Settings Application type: Single-page application\nApplication name: Enter your application name\nSign-in options: Username\nReturn URL: Enter your application URL\nRequired attributes for sign-up: email Step 3: Access Login Interface Review the hosted login page configuration\nTest the login interface\nStep 4: Save Configuration Details Important: Record the following values for application integration:\nUser Pool ID Client ID Step 5: Create Test User Account Create a new user account for testing\nComplete the registration process\nStep 6: Verify Authentication Log in using the created credentials Verify successful authentication Enter the username and password you set up earlier. Change password and confirm Step 7: Confirm User Status Verify the user status shows as Confirmed\nUser is now ready for application access\nContinue to 4. Storage \u0026amp; Database\nReferences Amazon Cognito Documentation Cognito User Pools Authentication Best Practices "
},
{
	"uri": "http://localhost:1313/6-lambda/6.4-withbedrock/",
	"title": "Interact with bedrock",
	"tags": [],
	"description": "",
	"content": "Lambda configuration Access to Amazon Lambda Console Create a new function:\nFunction name Run time: Python 3.12 Architecture: x86_64 IAM Role name Enter the following code import boto3 import json bedrock = boto3.client(\u0026#39;bedrock-runtime\u0026#39;) def invoke_bedrock(form_data): prompt = f\u0026#34;\u0026#34;\u0026#34; Dưới đây là dữ liệu biểu mẫu hóa đơn bán lẻ đã được Textract trích xuất: {json.dumps(form_data, indent=2)} Hãy phân tích và trả về một JSON với cấu trúc sau: {{ \u0026#34;invoice_id\u0026#34;: string, \u0026#34;invoice_date\u0026#34;: string, \u0026#34;cashier\u0026#34;: string, \u0026#34;counter\u0026#34;: string, \u0026#34;total_amount\u0026#34;: number, \u0026#34;discount\u0026#34;: number, \u0026#34;customer_paid\u0026#34;: number, \u0026#34;change\u0026#34;: number, \u0026#34;payment_method\u0026#34;: string, \u0026#34;items\u0026#34;: [ {{ \u0026#34;name\u0026#34;: string, \u0026#34;unit_price\u0026#34;: number }} ... ] }} Chỉ trả về đúng một chuỗi JSON hợp lệ. \u0026#34;\u0026#34;\u0026#34; try: # Gửi yêu cầu tới mô hình Bedrock response = bedrock.invoke_model( modelId=\u0026#34;anthropic.claude-3-haiku-20240307-v1:0\u0026#34;, contentType=\u0026#34;application/json\u0026#34;, accept=\u0026#34;application/json\u0026#34;, body=json.dumps({ \u0026#34;anthropic_version\u0026#34;: \u0026#34;bedrock-2023-05-31\u0026#34;, \u0026#34;messages\u0026#34;: [ { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt } ], \u0026#34;max_tokens\u0026#34;: 1024, \u0026#34;temperature\u0026#34;: 0.3 }) ) raw_output = json.loads(response[\u0026#39;body\u0026#39;].read()) print(\u0026#34;Raw output from Claude:\u0026#34;, raw_output) messages = raw_output.get(\u0026#34;content\u0026#34;, []) if isinstance(messages, list) and len(messages) \u0026gt; 0: text_content = messages[0].get(\u0026#34;text\u0026#34;, \u0026#34;\u0026#34;) start_index = text_content.find(\u0026#34;{\u0026#34;) end_index = text_content.rfind(\u0026#34;}\u0026#34;) + 1 if start_index != -1 and end_index != -1: json_string = text_content[start_index:end_index] # Trả về JSON hợp lệ return json.loads(json_string) else: print(\u0026#34;Không tìm thấy JSON trong phản hồi từ Claude.\u0026#34;) return {\u0026#34;error\u0026#34;: \u0026#34;No valid JSON found in Claude response\u0026#34;, \u0026#34;data\u0026#34;: text_content} else: print(\u0026#34;Claude trả về dữ liệu không hợp lệ.\u0026#34;) return {\u0026#34;error\u0026#34;: \u0026#34;Invalid response from Claude\u0026#34;} except Exception as e: print(f\u0026#34;Error invoking Bedrock: {str(e)}\u0026#34;) return {\u0026#34;error\u0026#34;: \u0026#34;Error invoking Bedrock\u0026#34;, \u0026#34;message\u0026#34;: str(e)} def lambda_handler(event, context): print(\u0026#34;Lambda B triggered\u0026#34;) # Lấy dữ liệu form_data từ event form_data = event.get(\u0026#34;form_data\u0026#34;, {}) # Nếu form_data không có, trả về lỗi ngay lập tức if not form_data: return {\u0026#34;error\u0026#34;: \u0026#34;No form data provided\u0026#34;} # Gọi hàm invoke_bedrock để lấy kết quả từ mô hình Claude summary = invoke_bedrock(form_data) # In ra kết quả từ Claude (nếu có) print(\u0026#34;Claude summary:\u0026#34;, summary) return summary IAM Role Access to IAM Role and add policy { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;bedrock:InvokeModel\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;textract:AnalyzeDocument\u0026#34;, \u0026#34;textract:DetectDocumentText\u0026#34;, \u0026#34;textract:GetDocumentAnalysis\u0026#34;, \u0026#34;textract:GetDocumentTextDetection\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;lambda:InvokeFunction\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:lambda:\u0026lt;YOUR-REGION\u0026gt;:\u0026lt;YOUR-ACCOUNT-ID\u0026gt;:function:lambdaToTextract\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;dynamodb:PutItem\u0026#34;, \u0026#34;dynamodb:BatchWriteItem\u0026#34;, \u0026#34;dynamodb:UpdateItem\u0026#34;, \u0026#34;dynamodb:Query\u0026#34;, \u0026#34;dynamodb:GetItem\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:dynamodb:\u0026lt;YOUR-REGION\u0026gt;:\u0026lt;YOUR-ACCOUNT-ID\u0026gt;:table/YOUR_TABLE_NAME\u0026#34; } ] } Continue to: 7. API Gateway Configuration\n"
},
{
	"uri": "http://localhost:1313/4-storage-db/",
	"title": "Storage and Database Configuration",
	"tags": [],
	"description": "",
	"content": "This section covers the setup of data storage components including DynamoDB for structured data and S3 for file storage.\nAmazon DynamoDB Configuration Step 1: Access DynamoDB Console Navigate to the DynamoDB Console\nStep 2: Create New Table Click Create table\nConfigure table settings\nStep 3: Define Table Schema Table name: Enter descriptive table name\nPartition key: Define primary key attribute\nSort key: Configure secondary key (if required)\nStep 4: Save Table Configuration Verify table creation success\nImportant: Record the table ARN for Lambda function configuration\nAmazon S3 Configuration Step 1: Access S3 Console Navigate to the S3 Console\nStep 2: Create S3 Bucket Click Create bucket\nConfigure bucket settings\nStep 3: Configure Bucket Properties Bucket name: Enter unique bucket name\nRegion: Select appropriate AWS region\nAccess settings: Configure according to security requirements\nStep 4: Save Bucket Configuration Verify bucket creation success\nImportant: Record the bucket ARN for Lambda function and application configuration\nContinue to 5. Document AI\nReferences Amazon DynamoDB Documentation Amazon S3 User Guide DynamoDB Best Practices "
},
{
	"uri": "http://localhost:1313/5-document-ai/",
	"title": "Document AI",
	"tags": [],
	"description": "",
	"content": "In this section, we will explore the roles of Amazon Textract and Amazon Bedrock in a serverless invoice processing system, along with how Guardrails protect sensitive information.\nArchitecture Overview The Document AI system includes the following key components:\nAmazon S3: Storage for input invoices and processing results AWS Lambda: Orchestrates the serverless processing workflow Amazon Textract: Extracts data from invoices Amazon Bedrock: Intelligent analysis and information processing Role of Amazon Textract Core Functions Amazon Textract is a fully managed machine learning service specialized for:\n1. Text and Structured Data Extraction\nRecognizes and extracts text from images and PDFs Detects structured data fields such as tables and forms Maintains the format and layout of original documents 2. Invoice and Receipt Analysis (Analyze Expense)\nAutomatically identifies key fields: Vendor Name Invoice Date Total Amount Tax Amount Line Items details Extracts information with high confidence scores Supports various invoice formats 3. Batch and Real-time Processing\nSynchronous processing for small documents (\u0026lt; 5MB) Asynchronous processing for large documents and batch processing Direct integration with S3 for automated processing Benefits in the System High Accuracy: Uses deep learning models trained on millions of documents No Training Required: Pre-trained models ready to use Scalable: Automatically scales with workload Cost-effective: Pay only for what you use Role of Amazon Bedrock Core Functions Amazon Bedrock provides a platform to access foundation models through APIs:\n1. Claude 3 Haiku - Selected Model\nHigh Speed: Fast response times, suitable for real-time processing Cost-effective: Low cost for high volume processing Efficient: Excellent performance for analysis and summarization tasks Multilingual: Supports Vietnamese and many other languages 2. Intelligent Analysis\nData Verification: Validates accuracy of numerical values Automatic Classification: Categorizes invoices by goods/services type Anomaly Detection: Identifies unreasonable values Information Summarization: Creates meaningful summaries from raw data 3. Natural Language Processing\nUnderstands context and meaning of information Answers questions about invoice content Generates insights and recommendations Formats output as required (JSON, text, etc.) Benefits in the System Serverless: No infrastructure management required Managed Service: AWS handles model updates and maintenance High Availability: High SLA for production workloads Integration: Easy integration with other AWS services Applications in Invoice Processing Financial Information Protection: Prevents exposure of account numbers and payment information Regulatory Compliance: Ensures compliance with regulations Data Privacy: Protects customer and vendor information Quality Control: Ensures quality and appropriate output Amazon Textract Workflow graph TB A[User/Client] --\u0026gt; B[AWS Amplify Frontend] B --\u0026gt; C[Amazon API Gateway] C --\u0026gt; D[AWS Lambda Upload Handler] D --\u0026gt; E[Amazon S3 File Storage] E --\u0026gt; F[AWS Lambda Textract Handler] F --\u0026gt; G[Amazon Textract Document Analysis] G --\u0026gt; H[Amazon DynamoDB Extracted Data] style A fill:#e3f2fd style B fill:#f3e5f5 style C fill:#e8f5e8 style D fill:#fff3e0 style E fill:#fce4ec style F fill:#fff3e0 style G fill:#e0f2f1 style H fill:#f1f8e9 Amazon Bedrock Workflow graph TB A[User/Client] --\u0026gt; B[AWS Amplify Frontend] B --\u0026gt; C[Amazon API Gateway] C --\u0026gt; D[AWS Lambda Bedrock Handler] D --\u0026gt; E[Amazon DynamoDB Get Textract Data] E --\u0026gt; F[Amazon Bedrock Claude 3 Haiku] F --\u0026gt; G[Amazon DynamoDB AI Analysis Result] style A fill:#e3f2fd style B fill:#f3e5f5 style C fill:#e8f5e8 style D fill:#fff3e0 style E fill:#f1f8e9 style F fill:#ffebee style G fill:#f1f8e9 Benefits of Serverless Architecture 1. Scalability\nAutomatically scales with demand Processes from a few invoices to thousands per second No capacity planning required 2. Cost Optimization\nPay-per-use model No idle resources Automatic resource management 3. Reliability\nBuilt-in fault tolerance Automatic retries and error handling Multi-AZ deployment 4. Maintenance\nMinimal operational overhead Automatic updates and patches Focus on business logic Reference Documentation Amazon Textract Documentation Amazon Bedrock User Guide Claude 3 Haiku Model Guide Continue to 6. Lambda Functions\n"
},
{
	"uri": "http://localhost:1313/6-lambda/",
	"title": "Lambda Configuration",
	"tags": [],
	"description": "",
	"content": "This section covers the configuration and deployment of serverless functions that power the document processing workflow.\nOverview The application utilizes multiple Lambda functions to handle different aspects of the invoice processing pipeline:\nDatabase Scanner: Retrieves and manages data from DynamoDB Image Upload Handler: Processes file uploads to S3 Textract Integration: Extracts data from invoice documents Bedrock Integration: Provides AI-powered analysis and insights Function Architecture Each Lambda function is designed with specific responsibilities to maintain separation of concerns and optimize performance. The functions work together to create a complete serverless processing pipeline that scales automatically based on demand.\nContinue to 6.1 Get Data From DB\nReferences AWS Lambda Documentation Lambda Best Practices Serverless Architecture Patterns "
},
{
	"uri": "http://localhost:1313/7-api-gateway/",
	"title": "API Gateway Configuration",
	"tags": [],
	"description": "",
	"content": "This section covers the setup of API Gateway to create secure, scalable REST APIs that connect the frontend application with backend Lambda functions.\nAPI Gateway Overview Core Functions 1. Request Management\nActs as the single entry point for all client requests Manages communication between frontend and backend services Provides centralized request/response handling 2. Request Routing\nRoutes HTTP/HTTPS requests to appropriate backend services Directs requests to specific Lambda functions based on endpoints Supports multiple integration types (Lambda, HTTP, AWS services) 3. Security Integration\nIntegrates with Amazon Cognito for authentication Supports OAuth2 and custom authorization Provides API key management and throttling Architecture Role In our serverless architecture, API Gateway serves as the orchestration layer:\nReceives requests from the frontend application Routes scan requests to the scan_lambda function Directs upload requests to the savePicture function Manages authentication through Cognito integration API Configuration Image Storage and Processing API Step 1: Create REST API Navigate to the Amazon API Gateway Console\nCreate new API\nSelect REST API Enter API name and Create Step 2: Create Upload Resource Create new resource\nResource name: Enter descriptive name Enable CORS: Check this option Step 3: Create Dynamic Path Resource Create child resource\nResource name: {filename} Enable CORS: Check this option Step 4: Configure POST Method Create method for file upload\nMethod type: POST Lambda Proxy Integration: Enable Lambda function: Select S3 upload handler function Step 5: Configure Response Headers Set response configuration\nResponse headers: Access-Control-Allow-Origin Response body: application/json Step 6: Configure Media Types Access API settings\nAdd media type for file uploads Data Retrieval API Step 1: Create View Resource Create new resource for data retrieval\nResource name: view-all Enable CORS: Check this option Create Step 2: Configure GET Method Create method for data retrieval\nMethod type: GET Lambda Proxy Integration: Enable Lambda function: Select DynamoDB scanner function Step 3: Deploy API Deploy the API to make it accessible\nImportant: Save the deployment URL for frontend integration Best Practices Security Always enable CORS for cross-origin requests Implement proper authentication and authorization Use API keys for additional access control Performance Enable caching for frequently accessed endpoints Configure appropriate throttling limits Monitor API usage and performance metrics Monitoring Set up CloudWatch logging for debugging Configure alarms for error rates and latency Use AWS X-Ray for distributed tracing Continue to 8. Testing\n"
},
{
	"uri": "http://localhost:1313/8-testing/",
	"title": "Application Testing",
	"tags": [],
	"description": "",
	"content": "This section covers comprehensive testing procedures to validate the functionality of the serverless invoice processing system.\nTesting Procedures Step 1: Authentication Testing Test Case 1.1: Invalid Login Attempt\nTry logging in with wrong account\nTest Case 1.2: Valid Login Attempt\nTry logging in with the correct account\nStep 2: File Upload Testing Select data as invoice image with extension .png\nUpload image\nStep 3: Storage Verification Check s3 bucket and see the photo uploaded\nCheck lambda log to see data saved to DynamoDB successfully\nCheck table in DynamoDB\nStep 4: Data Retrieval Testing Try viewing the data stored in the dynamo via the frontend\nStep 5: Multiple Upload Testing Continue uploading another invoice and it was also successful.\nContinue to 9. Cleanup\nReferences AWS Testing Best Practices API Gateway Testing Lambda Function Testing "
},
{
	"uri": "http://localhost:1313/9-delete-source/",
	"title": "Resource Cleanup",
	"tags": [],
	"description": "",
	"content": "This section provides a comprehensive guide for cleaning up all AWS resources created during the workshop to avoid unnecessary charges.\nCleanup Checklist Phase 1: Application Layer Cleanup 1. AWS Amplify Action: Delete the Amplify application Steps: Navigate to AWS Amplify Console Select your application Go to Actions → Delete app Confirm deletion by typing the app name 2. Amazon Route 53 Action: Delete hosted zone and records Steps: Navigate to Route 53 Console Delete all custom records (keep NS and SOA for last) Delete the hosted zone Update domain registrar DNS settings (if applicable) Phase 2: API and Compute Cleanup 1. Amazon API Gateway Action: Delete REST API Steps: Navigate to API Gateway Console Select your API Go to Actions → Delete API Confirm deletion 2. AWS Lambda Functions Action: Delete all Lambda functions Steps: Navigate to Lambda Console Delete each function individually: Database scanner function Image upload handler function Textract integration function Bedrock integration function Verify all functions are removed Phase 3: Storage and Database Cleanup 1. Amazon S3 Action: Empty and delete S3 buckets Steps: Navigate to S3 Console Empty the bucket first: Select bucket → Empty Type \u0026ldquo;permanently delete\u0026rdquo; to confirm Delete the bucket: Select bucket → Delete Type bucket name to confirm and delete bucket 2. Amazon DynamoDB Action: Delete DynamoDB tables Steps: Navigate to DynamoDB Console Select your table Go to Actions → Delete table Type \u0026ldquo;delete\u0026rdquo; to confirm Wait for deletion to complete Phase 4: Identity Cleanup Amazon Cognito Action: Delete User Pool Steps: Navigate to Cognito Console Select your User Pool Go to Actions → Delete user pool Type \u0026ldquo;delete\u0026rdquo; to confirm Phase 5: Monitoring and Logging Cleanup CloudWatch Logs Action: Delete log groups Steps: Navigate to CloudWatch Console Go to Logs → Log groups Delete Lambda function log groups Delete API Gateway log groups Important: Double-check all deletions before confirming. Resource deletion is typically irreversible and may result in permanent data loss.\nContinue to 10. Conclusion\nReferences AWS Resource Cleanup Best Practices AWS Cost Management AWS Billing and Cost Management User Guide "
},
{
	"uri": "http://localhost:1313/10-conclusion/",
	"title": "Conclusion",
	"tags": [],
	"description": "",
	"content": "Workshop Summary Congratulations! You have successfully completed the Serverless Invoice Reading and Storage System workshop. Throughout this hands-on experience, you have built a comprehensive, production-ready serverless application using multiple AWS services.\nWhat You\u0026rsquo;ve Accomplished 1. Serverless Architecture Mastery Designed and implemented a fully serverless system with automatic scaling Integrated multiple AWS services seamlessly without server management Created a cost-effective solution with pay-per-use pricing model 2. Frontend Development \u0026amp; Hosting Configured Amazon Route 53 for DNS management Deployed a responsive web application using AWS Amplify Implemented custom domain configuration with SSL certificates 3. Security \u0026amp; Authentication Set up Amazon Cognito for secure user authentication Implemented JWT token-based authorization Configured access control for API endpoints 4. Data Storage \u0026amp; Management Configured Amazon S3 for file storage with proper access policies Set up DynamoDB for structured data storage Implemented efficient data retrieval and management patterns 5. AI-Powered Document Processing Integrated Amazon Textract for intelligent document analysis Implemented Amazon Bedrock with Claude 3 Haiku for AI insights Created automated invoice processing workflows 6. Serverless Computing Developed multiple Lambda functions for different business logic Implemented event-driven architecture patterns Created scalable processing pipelines 7. API Development Built RESTful APIs using Amazon API Gateway Configured proper CORS and security headers Implemented multiple endpoints for different functionalities 8. Testing \u0026amp; Validation Performed comprehensive end-to-end testing Validated authentication flows and data processing Verified system integration and functionality Key Benefits Achieved Scalability Automatic scaling based on demand No capacity planning required Handles traffic spikes efficiently Cost Optimization Pay-only-for-what-you-use model No idle resource costs Optimized resource utilization Security Multi-layer security implementation Encrypted data transmission and storage Proper access control and authentication Maintainability Modular architecture with separation of concerns Easy to update and extend functionality Comprehensive logging and monitoring Real-World Applications The architecture and patterns you\u0026rsquo;ve learned can be applied to various use cases:\nDocument Processing Systems: Legal documents, medical records, financial statements Content Management Platforms: Media processing, file sharing, document collaboration E-commerce Solutions: Order processing, inventory management, customer portals Business Automation: Workflow automation, data processing pipelines, reporting systems Next Steps Enhance Your Solution Add more AI capabilities using additional Bedrock models Implement advanced analytics and reporting features Add real-time notifications using Amazon SNS Integrate with third-party services and APIs Production Considerations Implement comprehensive monitoring with CloudWatch Set up automated backup and disaster recovery Add performance optimization and caching layers Implement CI/CD pipelines for automated deployments Continue Learning Explore advanced AWS services and features Learn about microservices architecture patterns Study DevOps and infrastructure as code practices Investigate machine learning and AI integration patterns Resources for Further Learning AWS Well-Architected Framework AWS Serverless Application Lens AWS Lambda Best Practices Amazon API Gateway Developer Guide Final Thoughts You have successfully built a sophisticated serverless application that demonstrates modern cloud architecture principles. The skills and knowledge gained from this workshop provide a solid foundation for building scalable, secure, and cost-effective solutions in the cloud.\nRemember: Always follow the cleanup procedures outlined in the previous section to avoid unnecessary charges when you\u0026rsquo;re done experimenting with your implementation.\nThank you for completing this workshop, and we hope it has been a valuable learning experience!\nReferences AWS Well-Architected Framework AWS Serverless Application Repository AWS Architecture Center AWS Training and Certification "
},
{
	"uri": "http://localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]